{"jsonrpc":"2.0","id":1,"result":{"protocolVersion":1,"agentCapabilities":{"promptCapabilities":{"image":true,"embeddedContext":true},"mcpCapabilities":{"http":true,"sse":true}},"authMethods":[{"description":"Run `claude /login` in the terminal","name":"Log in with Claude Code","id":"claude-login"}]}}
{"jsonrpc":"2.0","id":2,"result":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","models":{"availableModels":[{"modelId":"default","name":"Default (recommended)","description":"Sonnet 4.5 Â· Smartest model for daily use"},{"modelId":"opus","name":"Opus","description":"Legacy: Opus 4.1 Â· Reaches usage limits faster"},{"modelId":"haiku","name":"Haiku","description":"Haiku 4.5 Â· Fastest model for simple tasks"}],"currentModelId":"default"},"modes":{"currentModeId":"default","availableModes":[{"id":"default","name":"Always Ask","description":"Prompts for permission on first use of each tool"},{"id":"acceptEdits","name":"Accept Edits","description":"Automatically accepts file edit permissions for the session"},{"id":"plan","name":"Plan Mode","description":"Claude can analyze but not modify files or execute commands"},{"id":"bypassPermissions","name":"Bypass Permissions","description":"Skips all permission prompts"}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"available_commands_update","availableCommands":[{"name":"check_py_proj_setup","description":"check the makefile and project configs for issues. the project should target python3.12 but suppo... (project, gitignored)","input":null},{"name":"handoff","description":"OVERVIEW (project, gitignored)","input":null},{"name":"all_tools","description":"List All Tools (project, gitignored)","input":null},{"name":"question","description":"Answer questions about the project structure and documentation without coding (project, gitignored)","input":null},{"name":"prime","description":"Read the `README.md` and `todos.md` files if they exist. Also read any docs in the ai-docs folder... (project, gitignored)","input":null},{"name":"merge-pr","description":"If there is an existing PR, make sure it's up to date and merge it. If there isn't an existing PR... (project, gitignored)","input":null},{"name":"rule2hook","description":"Task: Convert Project Rules to Claude Code Hooks (project, gitignored)","input":null},{"name":"create-pr","description":"Push changes and create PR (project, gitignored)","input":null},{"name":"create-issue","description":"Use the gh cli to create a new issue with the following description. (project, gitignored)","input":null},{"name":"audit","description":"Project audit (project, gitignored)","input":null},{"name":"sync-doc-to-impl","description":"If docs/DOCUMENTATION_STYLE_GUIDE.md exists read it. (project, gitignored)","input":null},{"name":"par-todo","description":"Read `todos.md` and ultrathink about how to adapt or add to the current systems for the requested... (project, gitignored)","input":null},{"name":"resume-work","description":"- Read the `handoff.md` file in the root of this project and continue any work it mentions. (project, gitignored)","input":null},{"name":"fix-issue","description":"Find and fix issue #$ARGUMENTS. Follow these steps: (project, gitignored)","input":null},{"name":"first-docs","description":"This tool has not been released yet, it does not net need a changelog or whats new sections. (project, gitignored)","input":null},{"name":"site-iteration","description":"Site iteration (project, gitignored)","input":null},{"name":"cleanup-claude","description":"Examine CLAUDE.md and ensure it is not overly verbose or redundant. (project, gitignored)","input":null},{"name":"git_status","description":"Understand the current state of the git repository (project, gitignored)","input":null},{"name":"check_py_proj_setup","description":"check the makefile and project configs for issues. the project should target python3.12 but suppo... (project)","input":null},{"name":"handoff","description":"OVERVIEW (project)","input":null},{"name":"all_tools","description":"List All Tools (project)","input":null},{"name":"question","description":"Answer questions about the project structure and documentation without coding (project)","input":null},{"name":"prime","description":"Read the `README.md` and `todos.md` files if they exist. Also read any docs in the ai-docs folder... (project)","input":null},{"name":"merge-pr","description":"If there is an existing PR, make sure it's up to date and merge it. If there isn't an existing PR... (project)","input":null},{"name":"rule2hook","description":"Task: Convert Project Rules to Claude Code Hooks (project)","input":null},{"name":"create-pr","description":"Push changes and create PR (project)","input":null},{"name":"create-issue","description":"Use the gh cli to create a new issue with the following description. (project)","input":null},{"name":"audit","description":"Project audit (project)","input":null},{"name":"sync-doc-to-impl","description":"If docs/DOCUMENTATION_STYLE_GUIDE.md exists read it. (project)","input":null},{"name":"par-todo","description":"Read `todos.md` and ultrathink about how to adapt or add to the current systems for the requested... (project)","input":null},{"name":"resume-work","description":"- Read the `handoff.md` file in the root of this project and continue any work it mentions. (project)","input":null},{"name":"fix-issue","description":"Find and fix issue #$ARGUMENTS. Follow these steps: (project)","input":null},{"name":"first-docs","description":"This tool has not been released yet, it does not net need a changelog or whats new sections. (project)","input":null},{"name":"site-iteration","description":"Site iteration (project)","input":null},{"name":"cleanup-claude","description":"Examine CLAUDE.md and ensure it is not overly verbose or redundant. (project)","input":null},{"name":"git_status","description":"Understand the current state of the git repository (project)","input":null},{"name":"compact","description":"Clear conversation history but keep a summary in context. Optional: /compact [instructions for summarization]","input":{"hint":"<optional custom summarization instructions>"}},{"name":"init","description":"Initialize a new CLAUDE.md file with codebase documentation","input":null},{"name":"pr-comments","description":"Get comments from a GitHub pull request","input":null},{"name":"review","description":"Review a pull request","input":null},{"name":"security-review","description":"Complete a security review of the pending changes on the current branch","input":null}]}}}
{"jsonrpc":"2.0","id":3,"result":{}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":""}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"I"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"'ll help"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" you fix all lint"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" and type errors."}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" Let me start by running the code"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" quality"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" checks to"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" see"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" what issues we have."}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01H2dkeecewPbseSSni64GSj","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Terminal","kind":"execute","content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01H2dkeecewPbseSSni64GSj","sessionUpdate":"tool_call","rawInput":{"command":"cd /Users/probello/Repos/par_cc_usage && uv run ruff check . 2>&1","description":"Check for ruff lint errors"},"status":"pending","title":"`cd /Users/probello/Repos/par_cc_usage && uv run ruff check . 2>&1`","kind":"execute","content":[{"type":"content","content":{"type":"text","text":"Check for ruff lint errors"}}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01Um5tMS6e4u2iRXo9fnSSyN","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Terminal","kind":"execute","content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01Um5tMS6e4u2iRXo9fnSSyN","sessionUpdate":"tool_call","rawInput":{"command":"cd /Users/probello/Repos/par_cc_usage && uv run pyright . 2>&1","description":"Check for pyright type errors"},"status":"pending","title":"`cd /Users/probello/Repos/par_cc_usage && uv run pyright . 2>&1`","kind":"execute","content":[{"type":"content","content":{"type":"text","text":"Check for pyright type errors"}}]}}}
{"jsonrpc":"2.0","id":0,"method":"terminal/create","params":{"command":"cd /Users/probello/Repos/par_cc_usage && uv run ruff check . 2>&1","sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","outputByteLimit":32000}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"tool_call_update","toolCallId":"toolu_01H2dkeecewPbseSSni64GSj","status":"in_progress","title":"Check for ruff lint errors","content":[{"type":"terminal","terminalId":"terminal-1"}]}}}
{"jsonrpc":"2.0","id":1,"method":"terminal/wait_for_exit","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","terminalId":"terminal-1"}}
{"jsonrpc":"2.0","id":2,"method":"terminal/output","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","terminalId":"terminal-1"}}
{"jsonrpc":"2.0","id":3,"method":"terminal/release","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","terminalId":"terminal-1"}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01H2dkeecewPbseSSni64GSj","sessionUpdate":"tool_call_update","status":"completed"}}}
{"jsonrpc":"2.0","id":4,"method":"terminal/create","params":{"command":"cd /Users/probello/Repos/par_cc_usage && uv run pyright . 2>&1","sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","outputByteLimit":32000}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"tool_call_update","toolCallId":"toolu_01Um5tMS6e4u2iRXo9fnSSyN","status":"in_progress","title":"Check for pyright type errors","content":[{"type":"terminal","terminalId":"terminal-2"}]}}}
{"jsonrpc":"2.0","id":5,"method":"terminal/wait_for_exit","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","terminalId":"terminal-2"}}
{"jsonrpc":"2.0","id":6,"method":"terminal/output","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","terminalId":"terminal-2"}}
{"jsonrpc":"2.0","id":7,"method":"terminal/release","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","terminalId":"terminal-2"}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01Um5tMS6e4u2iRXo9fnSSyN","sessionUpdate":"tool_call_update","status":"completed"}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":""}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"Let me run the automatic"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" fixes"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" for r"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"uff first"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":","}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" then work"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" on the remaining errors."}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"plan","entries":[{"content":"Fix all ruff lint errors with --fix","status":"in_progress","priority":"medium"},{"content":"Fix remaining ruff errors manually","status":"pending","priority":"medium"},{"content":"Fix pyright type errors in conftest.py","status":"pending","priority":"medium"},{"content":"Fix pyright type errors in test files","status":"pending","priority":"medium"},{"content":"Fix pyright type errors in mock_helpers.py","status":"pending","priority":"medium"},{"content":"Run final verification","status":"pending","priority":"medium"}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_0163aiNHGJD8SSDMAsDC4irX","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Terminal","kind":"execute","content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_0163aiNHGJD8SSDMAsDC4irX","sessionUpdate":"tool_call","rawInput":{"command":"cd /Users/probello/Repos/par_cc_usage && uv run ruff check --fix --unsafe-fixes . 2>&1","description":"Apply ruff auto-fixes including unsafe fixes"},"status":"pending","title":"`cd /Users/probello/Repos/par_cc_usage && uv run ruff check --fix --unsafe-fixes . 2>&1`","kind":"execute","content":[{"type":"content","content":{"type":"text","text":"Apply ruff auto-fixes including unsafe fixes"}}]}}}
{"jsonrpc":"2.0","id":8,"method":"terminal/create","params":{"command":"cd /Users/probello/Repos/par_cc_usage && uv run ruff check --fix --unsafe-fixes . 2>&1","sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","outputByteLimit":32000}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"tool_call_update","toolCallId":"toolu_0163aiNHGJD8SSDMAsDC4irX","status":"in_progress","title":"Apply ruff auto-fixes including unsafe fixes","content":[{"type":"terminal","terminalId":"terminal-3"}]}}}
{"jsonrpc":"2.0","id":9,"method":"terminal/wait_for_exit","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","terminalId":"terminal-3"}}
{"jsonrpc":"2.0","id":10,"method":"terminal/output","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","terminalId":"terminal-3"}}
{"jsonrpc":"2.0","id":11,"method":"terminal/release","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","terminalId":"terminal-3"}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_0163aiNHGJD8SSDMAsDC4irX","sessionUpdate":"tool_call_update","status":"completed"}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":""}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"Goo"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"d!"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" Most"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" errors"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" are fixed. Now"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" let me handle"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the remaining"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" r"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"uff"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" errors"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" manually"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":":"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"plan","entries":[{"content":"Fix all ruff lint errors with --fix","status":"completed","priority":"medium"},{"content":"Fix remaining ruff errors manually","status":"in_progress","priority":"medium"},{"content":"Fix pyright type errors in conftest.py","status":"pending","priority":"medium"},{"content":"Fix pyright type errors in test files","status":"pending","priority":"medium"},{"content":"Fix pyright type errors in mock_helpers.py","status":"pending","priority":"medium"},{"content":"Run final verification","status":"pending","priority":"medium"}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":""}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"Let me rea"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"d the files"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" with"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" remaining"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" errors:"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01S2qz82yr1BtqV5k5q8HbP1","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Read File","kind":"read","locations":[{"line":0}],"content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01S2qz82yr1BtqV5k5q8HbP1","sessionUpdate":"tool_call","rawInput":{"file_path":"/Users/probello/Repos/par_cc_usage/debug_cost.py"},"status":"pending","title":"Read /Users/probello/Repos/par_cc_usage/debug_cost.py","kind":"read","locations":[{"path":"/Users/probello/Repos/par_cc_usage/debug_cost.py","line":0}],"content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01NQioMecAMnnXD1CouAujUP","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Read File","kind":"read","locations":[{"line":0}],"content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01NQioMecAMnnXD1CouAujUP","sessionUpdate":"tool_call","rawInput":{"file_path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","offset":360,"limit":20},"status":"pending","title":"Read /Users/probello/Repos/par_cc_usage/tests/test_display.py (361 - 380)","kind":"read","locations":[{"path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","line":360}],"content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01LGH3ykcJxWJKmYiiMfbTmv","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Read File","kind":"read","locations":[{"line":0}],"content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01LGH3ykcJxWJKmYiiMfbTmv","sessionUpdate":"tool_call","rawInput":{"file_path":"/Users/probello/Repos/par_cc_usage/tests/test_statusline_git_config.py","offset":60,"limit":20},"status":"pending","title":"Read /Users/probello/Repos/par_cc_usage/tests/test_statusline_git_config.py (61 - 80)","kind":"read","locations":[{"path":"/Users/probello/Repos/par_cc_usage/tests/test_statusline_git_config.py","line":60}],"content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01LKYuRn47yhLk6WVr52PrFm","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Read File","kind":"read","locations":[{"line":0}],"content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01LKYuRn47yhLk6WVr52PrFm","sessionUpdate":"tool_call","rawInput":{"file_path":"/Users/probello/Repos/par_cc_usage/tests/test_utils.py","offset":395,"limit":20},"status":"pending","title":"Read /Users/probello/Repos/par_cc_usage/tests/test_utils.py (396 - 415)","kind":"read","locations":[{"path":"/Users/probello/Repos/par_cc_usage/tests/test_utils.py","line":395}],"content":[]}}}
{"jsonrpc":"2.0","id":12,"method":"fs/read_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","line":360,"limit":20}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01NQioMecAMnnXD1CouAujUP","sessionUpdate":"tool_call_update","status":"completed","content":[{"type":"content","content":{"type":"text","text":"```\n\n        # Test different usage levels - use percentage as 0-100 range\n        bar_color, text_color = display._get_progress_colors(30, 30000, 100000)\n        # Should be green for low usage (30%)\n        assert \"00FF00\" in bar_color\n\n        bar_color, text_color = display._get_progress_colors(80, 80000, 100000)\n        # Should be orange for medium usage (80%)\n        assert \"FFA500\" in bar_color\n\n        bar_color, _text_color = display._get_progress_colors(95, 95000, 100000)\n        # Should be red for high usage (95%)\n        assert \"FF0000\" in bar_color\n\n    def test_calculate_burn_rate(self, sample_usage_snapshot):\n        \"\"\"Test burn rate calculation text creation.\"\"\"\n        display = MonitorDisplay()\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n\n<file-read-info>Read lines 360-20. </file-read-info>\n```"}}]}}}
{"jsonrpc":"2.0","id":13,"method":"fs/read_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/debug_cost.py","line":1,"limit":2000}}
{"jsonrpc":"2.0","id":14,"method":"fs/read_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_statusline_git_config.py","line":60,"limit":20}}
{"jsonrpc":"2.0","id":15,"method":"fs/read_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_utils.py","line":395,"limit":20}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01S2qz82yr1BtqV5k5q8HbP1","sessionUpdate":"tool_call_update","status":"completed","content":[{"type":"content","content":{"type":"text","text":"```\n#!/usr/bin/env python3\n\"\"\"Debug script to analyze cost calculations.\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# Add the src directory to the path\nsrc_path = Path(__file__).parent / \"src\"\nsys.path.insert(0, str(src_path))\n\nfrom par_cc_usage.config import load_config\nfrom par_cc_usage.pricing import calculate_token_cost, debug_model_pricing\nfrom par_cc_usage.token_calculator import build_usage_snapshot\n\n\nasync def main():\n    \"\"\"Debug cost calculations.\"\"\"\n    config = load_config()\n\n    print(\"=== Building usage snapshot ===\")\n    snapshot = await build_usage_snapshot(config, progress_callback=None, suppress_output=True)\n\n    # Get current unified block\n    from par_cc_usage.token_calculator import get_current_unified_block\n    current_block = get_current_unified_block(snapshot.unified_blocks)\n\n    if not current_block:\n        print(\"No current unified block found\")\n        return\n\n    print(f\"=== Current Unified Block ({current_block.id}) ===\")\n    print(f\"Total entries: {len(current_block.entries)}\")\n    print(f\"Total tokens (display): {current_block.total_tokens:,}\")\n    print(f\"Total tokens (actual): {current_block.actual_tokens:,}\")\n    print(f\"Messages processed: {current_block.messages_processed}\")\n    print(f\"Models used: {current_block.full_model_names}\")\n\n    # Check a few sample entries\n    print(\"\\n=== Sample entries (first 5) ===\")\n    total_manual_cost = 0.0\n\n    for i, entry in enumerate(current_block.entries[:5]):\n        usage = entry.token_usage\n        print(f\"\\nEntry {i+1}:\")\n        print(f\"  Model: {entry.full_model_name}\")\n        print(f\"  Display tokens: in={usage.input_tokens:,}, out={usage.output_tokens:,}, cache_create={usage.cache_creation_input_tokens:,}, cache_read={usage.cache_read_input_tokens:,}\")\n        print(f\"  Actual tokens: in={usage.actual_input_tokens:,}, out={usage.actual_output_tokens:,}, cache_create={usage.actual_cache_creation_input_tokens:,}, cache_read={usage.actual_cache_read_input_tokens:,}\")\n\n        # Calculate cost for this entry\n        cost = await calculate_token_cost(\n            entry.full_model_name,\n            usage.actual_input_tokens,\n            usage.actual_output_tokens,\n            usage.actual_cache_creation_input_tokens,\n            usage.actual_cache_read_input_tokens,\n        )\n        print(f\"  Cost: ${cost.total_cost:.4f}\")\n        total_manual_cost += cost.total_cost\n\n    print(f\"\\n=== Manual cost calculation (first 5 entries): ${total_manual_cost:.4f} ===\")\n\n    # Get unified block total cost\n    unified_cost = await snapshot.get_unified_block_total_cost()\n    print(f\"=== Unified block total cost: ${unified_cost:.4f} ===\")\n\n    # Debug pricing for the most common model\n    if current_block.full_model_names:\n        most_common_model = next(iter(current_block.full_model_names))\n        print(f\"\\n=== Pricing debug for {most_common_model} ===\")\n        pricing_debug = await debug_model_pricing(most_common_model)\n        for key, value in pricing_debug.items():\n            print(f\"  {key}: {value}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```"}}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01LGH3ykcJxWJKmYiiMfbTmv","sessionUpdate":"tool_call_update","status":"completed","content":[{"type":"content","content":{"type":"text","text":"```\n\n        # Test clean with emoji\n        with patch(\"subprocess.run\") as mock_run:\n            mock_run.side_effect = [\n                Mock(returncode=0, stdout=\"main\\n\"),\n                Mock(returncode=0, stdout=\"\"),  # clean\n            ]\n\n            branch, status = manager._get_git_info(Path(\"/fake/repo\"))\n            assert status == \"ðŸŸ¢\"\n\n        # Test dirty with emoji\n        with patch(\"subprocess.run\") as mock_run:\n            mock_run.side_effect = [\n                Mock(returncode=0, stdout=\"main\\n\"),\n                Mock(returncode=0, stdout=\"A new_file.txt\\n\"),  # added file\n            ]\n\n            _branch, status = manager._get_git_info(Path(\"/fake/repo\"))\n            assert status == \"ðŸ”´\"\n\n<file-read-info>Read lines 60-20. </file-read-info>\n```"}}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01LKYuRn47yhLk6WVr52PrFm","sessionUpdate":"tool_call_update","status":"completed","content":[{"type":"content","content":{"type":"text","text":"```\n        }\n\n        for abbrev, expected in timezone_mappings.items():\n            with patch(\"par_cc_usage.utils.datetime\") as mock_datetime:\n                # Mock timezone object with tzname method\n                mock_tz = type('MockTZ', (), {})()\n                mock_tz.tzname = lambda dt: abbrev\n\n                mock_dt = type('MockDT', (), {})()\n                mock_dt.tzinfo = mock_tz\n\n                mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n                result = detect_system_timezone()\n                assert result == expected, f\"Expected {expected} for {abbrev}, got {result}\"\n\n<file-read-info>Read lines 395-15. </file-read-info>\n```"}}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":""}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"Now"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" let"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" me fix"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the remaining"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" r"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"uff"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" errors"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":":"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_0162pbHbKz4pjujPKFGbWVvS","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Edit","kind":"edit","content":[],"locations":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_0162pbHbKz4pjujPKFGbWVvS","sessionUpdate":"tool_call","rawInput":{"file_path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","old_string":"        bar_color, text_color = display._get_progress_colors(80, 80000, 100000)","new_string":"        bar_color, _text_color = display._get_progress_colors(80, 80000, 100000)"},"status":"pending","title":"Edit `/Users/probello/Repos/par_cc_usage/tests/test_display.py`","kind":"edit","content":[{"type":"diff","path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","oldText":"        bar_color, text_color = display._get_progress_colors(80, 80000, 100000)","newText":"        bar_color, _text_color = display._get_progress_colors(80, 80000, 100000)"}],"locations":[{"path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py"}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01Uu23uSvK2HvWzSoinJC8LD","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Edit","kind":"edit","content":[],"locations":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01Uu23uSvK2HvWzSoinJC8LD","sessionUpdate":"tool_call","rawInput":{"file_path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","old_string":"        # Test different usage levels - use percentage as 0-100 range\n        bar_color, text_color = display._get_progress_colors(30, 30000, 100000)","new_string":"        # Test different usage levels - use percentage as 0-100 range\n        bar_color, _text_color = display._get_progress_colors(30, 30000, 100000)"},"status":"pending","title":"Edit `/Users/probello/Repos/par_cc_usage/tests/test_display.py`","kind":"edit","content":[{"type":"diff","path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","oldText":"        # Test different usage levels - use percentage as 0-100 range\n        bar_color, text_color = display._get_progress_colors(30, 30000, 100000)","newText":"        # Test different usage levels - use percentage as 0-100 range\n        bar_color, _text_color = display._get_progress_colors(30, 30000, 100000)"}],"locations":[{"path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py"}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01Da3wGUVDsQvqjd2hDthSEM","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Edit","kind":"edit","content":[],"locations":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01Da3wGUVDsQvqjd2hDthSEM","sessionUpdate":"tool_call","rawInput":{"file_path":"/Users/probello/Repos/par_cc_usage/tests/test_utils.py","old_string":"        for abbrev, expected in timezone_mappings.items():\n            with patch(\"par_cc_usage.utils.datetime\") as mock_datetime:\n                # Mock timezone object with tzname method\n                mock_tz = type('MockTZ', (), {})()\n                mock_tz.tzname = lambda dt: abbrev\n\n                mock_dt = type('MockDT', (), {})()\n                mock_dt.tzinfo = mock_tz\n\n                mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n                result = detect_system_timezone()\n                assert result == expected, f\"Expected {expected} for {abbrev}, got {result}\"","new_string":"        for abbrev, expected in timezone_mappings.items():\n            with patch(\"par_cc_usage.utils.datetime\") as mock_datetime:\n                # Mock timezone object with tzname method\n                mock_tz = type('MockTZ', (), {})()\n                mock_tz.tzname = lambda dt, _abbrev=abbrev: _abbrev\n\n                mock_dt = type('MockDT', (), {})()\n                mock_dt.tzinfo = mock_tz\n\n                mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n                result = detect_system_timezone()\n                assert result == expected, f\"Expected {expected} for {abbrev}, got {result}\""},"status":"pending","title":"Edit `/Users/probello/Repos/par_cc_usage/tests/test_utils.py`","kind":"edit","content":[{"type":"diff","path":"/Users/probello/Repos/par_cc_usage/tests/test_utils.py","oldText":"        for abbrev, expected in timezone_mappings.items():\n            with patch(\"par_cc_usage.utils.datetime\") as mock_datetime:\n                # Mock timezone object with tzname method\n                mock_tz = type('MockTZ', (), {})()\n                mock_tz.tzname = lambda dt: abbrev\n\n                mock_dt = type('MockDT', (), {})()\n                mock_dt.tzinfo = mock_tz\n\n                mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n                result = detect_system_timezone()\n                assert result == expected, f\"Expected {expected} for {abbrev}, got {result}\"","newText":"        for abbrev, expected in timezone_mappings.items():\n            with patch(\"par_cc_usage.utils.datetime\") as mock_datetime:\n                # Mock timezone object with tzname method\n                mock_tz = type('MockTZ', (), {})()\n                mock_tz.tzname = lambda dt, _abbrev=abbrev: _abbrev\n\n                mock_dt = type('MockDT', (), {})()\n                mock_dt.tzinfo = mock_tz\n\n                mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n                result = detect_system_timezone()\n                assert result == expected, f\"Expected {expected} for {abbrev}, got {result}\""}],"locations":[{"path":"/Users/probello/Repos/par_cc_usage/tests/test_utils.py"}]}}}
{"jsonrpc":"2.0","id":16,"method":"fs/read_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py"}}
{"jsonrpc":"2.0","id":17,"method":"fs/write_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","content":"\"\"\"\nTests for the display module.\n\"\"\"\n\nfrom datetime import UTC, datetime, timedelta, timezone\nfrom unittest.mock import Mock, patch\n\nimport pytest\nfrom rich.console import Console\nfrom rich.panel import Panel\nfrom rich.table import Table\nfrom rich.text import Text\n\nfrom par_cc_usage.display import MonitorDisplay\nfrom par_cc_usage.enums import DisplayMode\n\n\ndef create_mock_config(display_mode=DisplayMode.COMPACT):\n    \"\"\"Create a mock config with all required fields for P90 functionality.\"\"\"\n    config = Mock()\n    from par_cc_usage.config import DisplayConfig\n    config.display = DisplayConfig(display_mode=display_mode)\n    config.max_cost_encountered = 0.0\n    config.max_tokens_encountered = 0\n    config.max_messages_encountered = 0\n    config.max_unified_block_tokens_encountered = 0\n    config.max_unified_block_messages_encountered = 0\n    config.max_unified_block_cost_encountered = 0.0\n    # Add P90 fields\n    config.p90_unified_block_tokens_encountered = 0\n    config.p90_unified_block_messages_encountered = 0\n    config.p90_unified_block_cost_encountered = 0.0\n    return config\nfrom par_cc_usage.models import Project, Session, TokenBlock, TokenUsage, UsageSnapshot\n\n\nclass TestMonitorDisplay:\n    \"\"\"Test the MonitorDisplay class.\"\"\"\n\n    def test_initialization_default(self):\n        \"\"\"Test MonitorDisplay initialization with defaults.\"\"\"\n        display = MonitorDisplay()\n\n        assert display.console is not None\n        assert display.layout is not None\n        assert display.show_sessions is False\n        assert display.time_format == \"24h\"\n\n    def test_initialization_with_params(self):\n        \"\"\"Test MonitorDisplay initialization with parameters.\"\"\"\n        console = Console()\n        display = MonitorDisplay(console=console, show_sessions=True, time_format=\"12h\")\n\n        assert display.console == console\n        assert display.show_sessions is True\n        assert display.time_format == \"12h\"\n\n    def test_initialization_with_compact_mode(self):\n        \"\"\"Test MonitorDisplay initialization with compact mode.\"\"\"\n\n        # Create config with compact mode\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config)\n\n        assert display.compact_mode is True\n        assert display.config == config\n\n    def test_initialization_with_normal_mode(self):\n        \"\"\"Test MonitorDisplay initialization with normal mode.\"\"\"\n\n        # Create config with normal mode\n        config = create_mock_config(DisplayMode.NORMAL)\n        display = MonitorDisplay(config=config)\n\n        assert display.compact_mode is False\n        assert display.config == config\n\n    def test_initialization_without_config(self):\n        \"\"\"Test MonitorDisplay initialization without config defaults to normal mode.\"\"\"\n        display = MonitorDisplay()\n\n        assert display.compact_mode is False\n        assert display.config is None\n\n    def test_setup_layout_without_sessions(self):\n        \"\"\"Test layout setup without sessions panel.\"\"\"\n        display = MonitorDisplay(show_sessions=False)\n\n        # Check layout structure\n        assert display.layout is not None\n        # The layout should have been split\n\n    def test_setup_layout_with_sessions(self):\n        \"\"\"Test layout setup with sessions panel.\"\"\"\n        display = MonitorDisplay(show_sessions=True)\n\n        # Check layout structure\n        assert display.layout is not None\n        # The layout should have sessions panel\n\n    def test_setup_layout_compact_mode(self):\n        \"\"\"Test layout setup in compact mode.\"\"\"\n\n        # Create config with compact mode\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config, show_sessions=True)\n\n        # Check layout structure - should only have header and progress\n        assert display.layout is not None\n        assert display.compact_mode is True\n        # In compact mode, sessions should not be shown even if requested\n\n    def test_setup_layout_compact_mode_without_sessions(self):\n        \"\"\"Test layout setup in compact mode without sessions.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config, show_sessions=False)\n\n        assert display.layout is not None\n        assert display.compact_mode is True\n\n    def test_create_header(self, sample_usage_snapshot):\n        \"\"\"Test header panel creation.\"\"\"\n        display = MonitorDisplay()\n\n        # Create header panel\n        panel = display._create_header(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        # Check that it contains expected header information\n        assert \"Active Projects\" in str(panel.renderable) or \"projects\" in str(panel.renderable).lower()\n\n    def test_create_block_progress_no_unified_block(self):\n        \"\"\"Test block progress panel when no unified block.\"\"\"\n        display = MonitorDisplay()\n\n        # Create snapshot without unified block\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={},\n            total_limit=None,\n        )\n\n        panel = display._create_block_progress(snapshot)\n\n        assert isinstance(panel, Panel)\n\n    def test_create_block_progress_with_block(self, sample_usage_snapshot):\n        \"\"\"Test block progress panel with active block.\"\"\"\n        display = MonitorDisplay()\n\n        # Mock unified block start time by setting block_start_override\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=2)\n\n        panel = display._create_block_progress(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        # The block progress panel doesn't have a title, it just contains the progress bar\n        # We can check that it has the right structure instead\n        assert panel.title is None\n\n    @pytest.mark.asyncio\n    async def test_create_progress_bars(self, sample_usage_snapshot):\n        \"\"\"Test progress bars creation.\"\"\"\n        display = MonitorDisplay()\n\n        panel = await display._create_progress_bars(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Token Usage by Model\"\n\n    @pytest.mark.asyncio\n    async def test_create_progress_bars_compact_mode(self, sample_usage_snapshot):\n        \"\"\"Test progress bars creation in compact mode.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config)\n\n        panel = await display._create_progress_bars(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Token Usage by Model\"\n        # In compact mode, should not show traditional progress bars\n\n    def test_create_model_displays_compact_mode(self):\n        \"\"\"Test model displays in compact mode.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config)\n\n        model_tokens = {\"claude-3-5-sonnet\": 1000, \"claude-3-opus\": 500}\n\n        displays = display._create_model_displays(model_tokens)\n\n        assert len(displays) == 2\n        for display_text in displays:\n            assert isinstance(display_text, Text)\n\n    def test_create_model_displays_normal_mode(self):\n        \"\"\"Test model displays in normal mode.\"\"\"\n\n        config = create_mock_config(DisplayMode.NORMAL)\n        display = MonitorDisplay(config=config)\n\n        model_tokens = {\"claude-3-5-sonnet\": 1000}\n\n        displays = display._create_model_displays(model_tokens)\n\n        assert len(displays) == 1\n        display_text = displays[0]\n        assert isinstance(display_text, Text)\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_no_sessions(self):\n        \"\"\"Test sessions table with no active sessions.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create empty snapshot\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={},\n            total_limit=None,\n        )\n\n        panel = await display._create_sessions_table(snapshot)\n\n        assert isinstance(panel, Panel)\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_with_sessions(self, sample_usage_snapshot):\n        \"\"\"Test sessions table with active sessions.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        panel = await display._create_sessions_table(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n\n    def test_update_with_compact_mode(self, sample_usage_snapshot):\n        \"\"\"Test update method in compact mode only updates essential elements.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)  # Add max_cost_encountered attribute\n\n        display = MonitorDisplay(config=config)\n\n        # Create a proper mock layout that supports item assignment\n        mock_layout = {}\n        display.layout = mock_layout\n\n        # The update method expects certain layout keys to exist\n        mock_layout[\"header\"] = Mock()\n        mock_layout[\"progress\"] = Mock()\n        mock_layout[\"block_progress\"] = Mock()\n        mock_layout[\"tool_usage\"] = Mock()\n        mock_layout[\"sessions\"] = Mock()\n\n        # Update should work in compact mode\n        display.update(sample_usage_snapshot)\n\n        # Verify that layout updates were called\n        assert mock_layout[\"header\"].update.called\n        assert mock_layout[\"progress\"].update.called\n\n    def test_format_time_24h(self):\n        \"\"\"Test time formatting in 24-hour format.\"\"\"\n        from par_cc_usage.utils import format_time\n\n        test_time = datetime(2024, 7, 8, 14, 30, 45, tzinfo=UTC)\n        formatted = format_time(test_time, \"24h\")\n\n        # Should contain 24-hour formatted time\n        assert \"14:30\" in formatted\n\n    def test_format_time_12h(self):\n        \"\"\"Test time formatting in 12-hour format.\"\"\"\n        from par_cc_usage.utils import format_time\n\n        test_time = datetime(2024, 7, 8, 14, 30, 45, tzinfo=UTC)\n        formatted = format_time(test_time, \"12h\")\n\n        # Should contain 12-hour formatted time\n        assert \"PM\" in formatted or \"AM\" in formatted\n\n    def test_compact_mode_hides_sessions_even_when_requested(self):\n        \"\"\"Test that compact mode hides sessions even when show_sessions=True.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        # Request sessions to be shown, but compact mode should override\n        display = MonitorDisplay(config=config, show_sessions=True)\n\n        assert display.compact_mode is True\n        assert display.show_sessions is True  # The setting is preserved\n        # But in compact mode, sessions should not be displayed in the layout\n\n    @pytest.mark.asyncio\n    async def test_compact_mode_burn_rate_calculation(self, sample_usage_snapshot):\n        \"\"\"Test burn rate calculation and display in compact mode.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config)\n\n        # Create progress bars panel which includes burn rate in compact mode\n        panel = await display._create_progress_bars(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        # Compact mode should still show burn rate metrics\n\n    def test_update_display(self, sample_usage_snapshot):\n        \"\"\"Test display update.\"\"\"\n        display = MonitorDisplay()\n\n        # Should not raise an error\n        display.update(sample_usage_snapshot)\n\n    def test_get_model_emoji(self):\n        \"\"\"Test model emoji mapping.\"\"\"\n        display = MonitorDisplay()\n\n        # Test known models - use correct emojis\n        assert display._get_model_emoji(\"opus\") == \"ðŸš€\"\n        assert display._get_model_emoji(\"sonnet\") == \"âš¡\"\n        assert display._get_model_emoji(\"haiku\") == \"ðŸ’¨\"\n        assert display._get_model_emoji(\"claude\") == \"ðŸ¤–\"\n        assert display._get_model_emoji(\"gpt\") == \"ðŸ§ \"\n        assert display._get_model_emoji(\"llama\") == \"ðŸ¦™\"\n        assert display._get_model_emoji(\"unknown\") == \"â“\"\n\n    def test_create_model_displays(self):\n        \"\"\"Test model display creation.\"\"\"\n        display = MonitorDisplay()\n\n        model_tokens = {\n            \"opus\": 50000,\n            \"sonnet\": 30000,\n            \"haiku\": 20000\n        }\n\n        displays = display._create_model_displays(model_tokens)\n\n        assert isinstance(displays, list)\n        assert len(displays) == 3\n        # Should be sorted alphabetically by model name\n        display_strs = [str(display) for display in displays]\n        assert any(\"Haiku\" in d for d in display_strs)\n        assert any(\"Opus\" in d for d in display_strs)\n        assert any(\"Sonnet\" in d for d in display_strs)\n\n    def test_get_progress_colors(self):\n        \"\"\"Test progress color determination.\"\"\"\n        display = MonitorDisplay()\n\n        # Test different usage levels - use percentage as 0-100 range\n        bar_color, text_color = display._get_progress_colors(30, 30000, 100000)\n        # Should be green for low usage (30%)\n        assert \"00FF00\" in bar_color\n\n        bar_color, _text_color = display._get_progress_colors(80, 80000, 100000)\n        # Should be orange for medium usage (80%)\n        assert \"FFA500\" in bar_color\n\n        bar_color, _text_color = display._get_progress_colors(95, 95000, 100000)\n        # Should be red for high usage (95%)\n        assert \"FF0000\" in bar_color\n\n    def test_calculate_burn_rate(self, sample_usage_snapshot):\n        \"\"\"Test burn rate calculation text creation.\"\"\"\n        display = MonitorDisplay()\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        text = display._calculate_burn_rate_sync(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n\n    @pytest.mark.asyncio\n    async def test_calculate_burn_rate_async_without_pricing(self, sample_usage_snapshot):\n        \"\"\"Test async burn rate calculation without pricing enabled.\"\"\"\n        # Mock config without pricing\n        mock_config = Mock()\n        mock_config.display.show_pricing = False\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        text = await display._calculate_burn_rate(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n        assert \"$\" not in text.plain  # Should not have estimated cost when pricing disabled\n\n    @pytest.mark.asyncio\n    async def test_calculate_burn_rate_async_with_pricing(self, sample_usage_snapshot):\n        \"\"\"Test async burn rate calculation with pricing enabled.\"\"\"\n        # Mock config with pricing enabled\n        mock_config = Mock()\n        mock_config.display.show_pricing = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        # Mock the get_unified_block_total_cost method to return a test cost\n        async def mock_get_cost():\n            return 10.50  # $10.50 current cost\n        sample_usage_snapshot.get_unified_block_total_cost = mock_get_cost\n\n        text = await display._calculate_burn_rate(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n        # Should have estimated cost when pricing enabled and cost available\n        assert \"Est:\" in text.plain and \"$\" in text.plain\n\n    @pytest.mark.asyncio\n    async def test_calculate_burn_rate_async_pricing_error(self, sample_usage_snapshot):\n        \"\"\"Test async burn rate calculation when pricing calculation fails.\"\"\"\n        # Mock config with pricing enabled\n        mock_config = Mock()\n        mock_config.display.show_pricing = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        # Mock the get_unified_block_total_cost method to raise an exception\n        async def mock_get_cost_error():\n            raise Exception(\"Pricing calculation failed\")\n        sample_usage_snapshot.get_unified_block_total_cost = mock_get_cost_error\n\n        text = await display._calculate_burn_rate(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n        # Should not break when pricing fails - graceful degradation\n\n    @pytest.mark.asyncio\n    async def test_calculate_burn_rate_async_zero_cost(self, sample_usage_snapshot):\n        \"\"\"Test async burn rate calculation with zero cost.\"\"\"\n        # Mock config with pricing enabled\n        mock_config = Mock()\n        mock_config.display.show_pricing = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        # Mock the get_unified_block_total_cost method to return zero cost\n        async def mock_get_zero_cost():\n            return 0.0\n        sample_usage_snapshot.get_unified_block_total_cost = mock_get_zero_cost\n\n        text = await display._calculate_burn_rate(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n        # Should not show cost estimate when cost is zero\n\n    def test_calculate_eta_display(self, sample_usage_snapshot):\n        \"\"\"Test ETA display calculation.\"\"\"\n        display = MonitorDisplay()\n\n        # Mock values for ETA calculation\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        eta_result = display._calculate_eta_display(sample_usage_snapshot, 50000, 100000, 833.33)  # 50k tokens/hour rate\n\n        assert isinstance(eta_result, tuple)  # Should be a tuple\n        assert len(eta_result) == 2  # (display_string, eta_before_block_end)\n        display_string, eta_before_block_end = eta_result\n        assert isinstance(display_string, str)\n        assert isinstance(eta_before_block_end, bool)\n\n    @patch('par_cc_usage.display.Live')\n    def test_live_context_manager(self, mock_live_class, sample_usage_snapshot):\n        \"\"\"Test using display update method.\"\"\"\n        mock_live = Mock()\n        mock_live_class.return_value = mock_live\n\n        display = MonitorDisplay()\n\n        # Just test that update method works\n        display.update(sample_usage_snapshot)\n\n        # The update method should work without errors\n        assert True\n\n    @pytest.mark.asyncio\n    async def test_create_progress_bars_with_limit(self, sample_usage_snapshot):\n        \"\"\"Test progress bars with token limit set.\"\"\"\n        display = MonitorDisplay()\n\n        # Set a token limit\n        sample_usage_snapshot.total_limit = 100000\n\n        panel = await display._create_progress_bars(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Token Usage by Model\"\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_with_unified_block(self, sample_usage_snapshot):\n        \"\"\"Test sessions table filtering by unified block.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Set unified block time\n        block_start = datetime.now(UTC) - timedelta(hours=2)\n        sample_usage_snapshot.block_start_override = block_start\n\n        # Ensure the session's block matches\n        for project in sample_usage_snapshot.projects.values():\n            for session in project.sessions.values():\n                for block in session.blocks:\n                    block.start_time = block_start\n\n        panel = await display._create_sessions_table(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n\n    def test_create_header_with_no_limit(self, sample_usage_snapshot):\n        \"\"\"Test header creation when no token limit is set.\"\"\"\n        display = MonitorDisplay()\n\n        # Remove token limit\n        sample_usage_snapshot.total_limit = None\n\n        panel = display._create_header(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        # Just check that the header is created successfully\n        assert \"Active\" in str(panel.renderable) or \"projects\" in str(panel.renderable).lower()\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_project_aggregation_mode(self, sample_usage_snapshot):\n        \"\"\"Test sessions table with project aggregation enabled.\"\"\"\n        # Mock config with project aggregation enabled\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n        mock_config.display.show_tool_usage = False  # Disable tool usage for consistent column count\n        mock_config.display.show_pricing = False  # Disable pricing for testing\n\n        display = MonitorDisplay(config=mock_config)\n\n        panel = await display._create_sessions_table(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Projects with Activity in Current Block\"\n\n        # The table should have different columns for project mode\n        table = panel.renderable\n        assert isinstance(table, Table)\n        # Check that it has the expected columns for project aggregation (Project, Model, Tokens, Messages)\n        assert len(table.columns) == 4  # Project, Model, Tokens, Messages\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_session_aggregation_mode(self, sample_usage_snapshot):\n        \"\"\"Test sessions table with session aggregation enabled.\"\"\"\n        # Mock config with project aggregation disabled\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n        mock_config.display.show_tool_usage = False  # Disable tool usage for consistent column count\n        mock_config.display.show_pricing = False  # Disable pricing for testing\n\n        display = MonitorDisplay(config=mock_config)\n\n        panel = await display._create_sessions_table(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Sessions with Activity in Current Block\"\n\n        # The table should have different columns for session mode\n        table = panel.renderable\n        assert isinstance(table, Table)\n        # Check that it has the expected columns for session aggregation (Project, Session ID, Model, Tokens, Messages)\n        assert len(table.columns) == 5  # Project, Session ID, Model, Tokens, Messages\n\n    def test_strip_project_name_with_config(self):\n        \"\"\"Test project name stripping with configuration.\"\"\"\n        mock_config = Mock()\n        mock_config.display.project_name_prefixes = [\"-Users-johndoe-\", \"-home-\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Test prefix stripping\n        assert display._strip_project_name(\"-Users-johndoe-MyProject\") == \"MyProject\"\n        assert display._strip_project_name(\"-home-MyProject\") == \"MyProject\"\n        assert display._strip_project_name(\"MyProject\") == \"MyProject\"  # No prefix to strip\n\n    def test_strip_project_name_no_config(self):\n        \"\"\"Test project name stripping without configuration.\"\"\"\n        display = MonitorDisplay(config=None)\n\n        # Without config, should return original name\n        assert display._strip_project_name(\"-Users-johndoe-MyProject\") == \"-Users-johndoe-MyProject\"\n        assert display._strip_project_name(\"MyProject\") == \"MyProject\"\n\n    def test_strip_project_name_empty_prefixes(self):\n        \"\"\"Test project name stripping with empty prefixes.\"\"\"\n        mock_config = Mock()\n        mock_config.display.project_name_prefixes = []\n\n        display = MonitorDisplay(config=mock_config)\n\n        # With empty prefixes, should return original name\n        assert display._strip_project_name(\"-Users-johndoe-MyProject\") == \"-Users-johndoe-MyProject\"\n        assert display._strip_project_name(\"MyProject\") == \"MyProject\"\n\n    @pytest.mark.asyncio\n    async def test_populate_project_table(self, sample_usage_snapshot):\n        \"\"\"Test populating table with project aggregation data.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n        mock_config.display.project_name_prefixes = [\"-Users-\"]\n        mock_config.display.show_tool_usage = False  # Disable tool usage for consistent column count\n        mock_config.display.show_pricing = False  # Disable pricing for testing\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create a table to populate\n        table = Table()\n\n        # Mock the project methods\n        project = next(iter(sample_usage_snapshot.projects.values()))\n        project.get_unified_block_tokens = Mock(return_value=5000)\n        project.get_unified_block_models = Mock(return_value={\"claude-3-5-sonnet-latest\", \"claude-3-opus-latest\"})\n        project.get_unified_block_latest_activity = Mock(return_value=datetime.now(UTC))\n\n        # Call the method\n        await display._populate_project_table(table, sample_usage_snapshot, None)\n\n        # Verify the table was populated\n        assert len(table.columns) == 4  # Project, Model, Tokens, Messages\n        assert table.row_count >= 0  # Should have at least attempted to add rows\n\n    @pytest.mark.asyncio\n    async def test_populate_session_table(self, sample_usage_snapshot):\n        \"\"\"Test populating table with session aggregation data.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n        mock_config.display.project_name_prefixes = [\"-Users-\"]\n        mock_config.display.show_tool_usage = False  # Disable tool usage for consistent column count\n        mock_config.display.show_pricing = False  # Disable pricing for testing\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create a table to populate\n        table = Table()\n\n        # Call the method\n        await display._populate_session_table(table, sample_usage_snapshot, None)\n\n        # Verify the table was populated\n        assert len(table.columns) == 5  # Project, Session ID, Model, Tokens, Messages\n        assert table.row_count >= 0  # Should have at least attempted to add rows\n\n    def test_calculate_session_data(self, sample_usage_snapshot):\n        \"\"\"Test calculating session data for aggregation.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Get a session from the snapshot\n        project = next(iter(sample_usage_snapshot.projects.values()))\n        session = next(iter(project.sessions.values()))\n\n        # Call the method - now returns 5 values\n        session_tokens, session_models, session_latest_activity, session_tools, session_tool_calls = display._calculate_session_data(session, None)\n\n        # Verify the results\n        assert isinstance(session_tokens, int)\n        assert isinstance(session_models, set)\n        assert session_latest_activity is None or isinstance(session_latest_activity, datetime)\n        assert isinstance(session_tools, set)\n        assert isinstance(session_tool_calls, int)\n\n    def test_should_include_block_no_unified_start(self):\n        \"\"\"Test block inclusion logic without unified start time.\"\"\"\n        display = MonitorDisplay()\n\n        # Mock active block\n        mock_block = Mock()\n        mock_block.is_active = True\n\n        # With no unified start, active blocks should be included\n        assert display._should_include_block(mock_block, None) is True\n\n        # Inactive blocks should not be included\n        mock_block.is_active = False\n        assert display._should_include_block(mock_block, None) is False\n\n    def test_should_include_block_with_unified_start(self):\n        \"\"\"Test block inclusion logic with unified start time.\"\"\"\n        display = MonitorDisplay()\n\n        unified_start = datetime.now(UTC)\n\n        # Mock active block that overlaps with unified window\n        mock_block = Mock()\n        mock_block.is_active = True\n        mock_block.start_time = unified_start - timedelta(hours=1)  # Starts before unified block ends\n        mock_block.actual_end_time = unified_start + timedelta(hours=1)  # Ends after unified block starts\n        mock_block.end_time = unified_start + timedelta(hours=4)\n\n        # Should be included (overlaps with unified window)\n        assert display._should_include_block(mock_block, unified_start) is True\n\n        # Mock block that doesn't overlap\n        mock_block.start_time = unified_start + timedelta(hours=6)  # Starts after unified block ends\n        mock_block.actual_end_time = unified_start + timedelta(hours=7)\n        mock_block.end_time = unified_start + timedelta(hours=11)\n\n        # Should not be included (no overlap)\n        assert display._should_include_block(mock_block, unified_start) is False\n\n    def test_add_empty_row_if_needed_project_mode(self):\n        \"\"\"Test adding empty row in project aggregation mode.\"\"\"\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create empty table\n        table = Table()\n        table.add_column(\"Project\")\n        table.add_column(\"Model\")\n        table.add_column(\"Tokens\")\n\n        # Add empty row\n        display._add_empty_row_if_needed(table)\n\n        # Should have added one row\n        assert table.row_count == 1\n\n    def test_add_empty_row_if_needed_session_mode(self):\n        \"\"\"Test adding empty row in session aggregation mode.\"\"\"\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create empty table\n        table = Table()\n        table.add_column(\"Project\")\n        table.add_column(\"Session ID\")\n        table.add_column(\"Model\")\n        table.add_column(\"Tokens\")\n\n        # Add empty row\n        display._add_empty_row_if_needed(table)\n\n        # Should have added one row\n        assert table.row_count == 1\n\n    def test_get_table_title_project_mode(self):\n        \"\"\"Test getting table title for project aggregation mode.\"\"\"\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        title = display._get_table_title()\n        assert title == \"Projects with Activity in Current Block\"\n\n    def test_get_table_title_session_mode(self):\n        \"\"\"Test getting table title for session aggregation mode.\"\"\"\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n\n        display = MonitorDisplay(config=mock_config)\n\n        title = display._get_table_title()\n        assert title == \"Sessions with Activity in Current Block\"\n\n\nclass TestMonitorDisplayEdgeCases:\n    \"\"\"Test edge cases and missing coverage for MonitorDisplay.\"\"\"\n\n    def test_block_progress_with_timezone_mismatch(self):\n        \"\"\"Test block progress when unified block and current time have different timezones.\"\"\"\n        from datetime import timedelta\n\n        # Create snapshot with UTC time\n        utc_time = datetime.now(UTC)\n\n        # Create a token usage and block\n        token_usage = TokenUsage(\n            input_tokens=100,\n            output_tokens=50,\n            model=\"claude-3-5-sonnet-latest\"\n        )\n\n        # Create block with a different timezone (EST)\n        est_tz = timezone(timedelta(hours=-5))\n        block_start = utc_time.replace(tzinfo=est_tz)\n\n        block = TokenBlock(\n            start_time=block_start,\n            end_time=block_start + timedelta(hours=1),\n            session_id=\"session_1\",\n            project_name=\"project_1\",\n            model=\"claude-3-5-sonnet-latest\",\n            token_usage=token_usage,\n            models_used={\"claude-3-5-sonnet-latest\"}\n        )\n\n        session = Session(\n            session_id=\"session_1\",\n            project_name=\"project_1\",\n            model=\"claude-3-5-sonnet-latest\"\n        )\n        session.blocks = [block]\n\n        project = Project(name=\"project_1\")\n        project.sessions = {\"session_1\": session}\n\n        # Override the unified block start time to trigger timezone conversion\n        snapshot = UsageSnapshot(\n            timestamp=utc_time,\n            projects={\"project_1\": project}\n        )\n        snapshot.block_start_override = block_start\n\n        display = MonitorDisplay()\n        result = display._create_block_progress(snapshot)\n\n        # Should not raise an error and should return a Panel\n        assert isinstance(result, Panel)\n\n    def test_get_model_emoji_all_types(self):\n        \"\"\"Test model emoji for all supported model types.\"\"\"\n        display = MonitorDisplay()\n\n        # Test all specific model types\n        assert display._get_model_emoji(\"claude-3-opus-latest\") == \"ðŸš€\"\n        assert display._get_model_emoji(\"claude-3-sonnet-latest\") == \"âš¡\"\n        assert display._get_model_emoji(\"claude-3-haiku-latest\") == \"ðŸ’¨\"\n        assert display._get_model_emoji(\"claude-2\") == \"ðŸ¤–\"\n        assert display._get_model_emoji(\"gpt-4\") == \"ðŸ§ \"\n        assert display._get_model_emoji(\"llama-2\") == \"ðŸ¦™\"\n        assert display._get_model_emoji(\"unknown-model\") == \"â“\"\n\n    def test_get_progress_colors_all_ranges(self):\n        \"\"\"Test progress colors for all percentage ranges.\"\"\"\n        display = MonitorDisplay()\n\n        # Test low usage (< 50%) - green (now includes color in style)\n        bar_color, text_style = display._get_progress_colors(25.0, 25000, 100000)\n        assert bar_color == \"#00FF00\"\n        assert text_style == \"bold #00FF00\"  # Now includes color with theme system\n\n        # Test medium usage (50-75%) - yellow\n        bar_color, text_style = display._get_progress_colors(60.0, 60000, 100000)\n        assert bar_color == \"#FFFF00\"\n        assert text_style == \"bold #FFFF00\"\n\n        # Test high usage (75-90%) - orange\n        bar_color, text_style = display._get_progress_colors(80.0, 80000, 100000)\n        assert bar_color == \"#FFA500\"\n        assert text_style == \"bold #FFA500\"\n\n        # Test very high usage (> 90%) - red (uses get_style for critical)\n        bar_color, text_style = display._get_progress_colors(95.0, 95000, 100000)\n        assert bar_color == \"#FF0000\"\n        assert text_style == \"#FF0000 bold\"  # get_style puts color first\n\n    def test_create_tool_usage_table_with_tools(self):\n        \"\"\"Test tool usage table creation when tools are used.\"\"\"\n        # Create snapshot with tool usage\n        now = datetime.now(UTC)\n\n        token_usage = TokenUsage(\n            input_tokens=100,\n            output_tokens=50,\n            model=\"claude-3-5-sonnet-latest\",\n            tools_used=[\"Read\", \"Edit\", \"Bash\"],\n            tool_use_count=5\n        )\n\n        block = TokenBlock(\n            start_time=now,\n            end_time=now + timedelta(hours=1),\n            session_id=\"session_1\",\n            project_name=\"project_1\",\n            model=\"claude-3-5-sonnet-latest\",\n            token_usage=token_usage,\n            models_used={\"claude-3-5-sonnet-latest\"},\n            tools_used={\"Read\", \"Edit\", \"Bash\"},\n            total_tool_calls=5,\n            tool_call_counts={\"Read\": 2, \"Edit\": 2, \"Bash\": 1}\n        )\n\n        session = Session(\n            session_id=\"session_1\",\n            project_name=\"project_1\",\n            model=\"claude-3-5-sonnet-latest\"\n        )\n        session.blocks = [block]\n\n        project = Project(name=\"project_1\")\n        project.sessions = {\"session_1\": session}\n\n        snapshot = UsageSnapshot(\n            timestamp=now,\n            projects={\"project_1\": project}\n        )\n\n        # Mock config to enable tool usage display\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = True\n\n        display = MonitorDisplay(config=mock_config)\n        result = display._create_tool_usage_table(snapshot)\n\n        # Should return a Table\n        assert isinstance(result, Table)\n\n    def test_create_tool_usage_table_disabled(self):\n        \"\"\"Test tool usage table when disabled in config.\"\"\"\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        # Mock config to disable tool usage display\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = False\n\n        display = MonitorDisplay(config=mock_config)\n        result = display._create_tool_usage_table(snapshot)\n\n        # Should return a Table even when disabled, but empty\n        assert isinstance(result, Table)\n\n    def test_create_tool_usage_table_no_config(self):\n        \"\"\"Test tool usage table with no config.\"\"\"\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        display = MonitorDisplay(config=None)\n        result = display._create_tool_usage_table(snapshot)\n\n        # Should return a Table even when no config, but empty\n        assert isinstance(result, Table)\n\n    def test_create_tool_usage_table_empty_tools(self):\n        \"\"\"Test tool usage table with no tools used.\"\"\"\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        # Mock config to enable tool usage display\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = True\n\n        display = MonitorDisplay(config=mock_config)\n        result = display._create_tool_usage_table(snapshot)\n\n        # Should return a Table even with empty tools\n        assert isinstance(result, Table)\n\n    def test_calculate_burn_rate_no_block(self):\n        \"\"\"Test burn rate calculation with no active block.\"\"\"\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        display = MonitorDisplay()\n\n        # Should handle no active block gracefully and return Text\n        burn_rate_text = display._calculate_burn_rate_sync(snapshot, 1000, 5000)\n        assert isinstance(burn_rate_text, Text)\n\n    def test_calculate_eta_display_infinite(self):\n        \"\"\"Test ETA display when burn rate is zero (infinite time).\"\"\"\n        display = MonitorDisplay()\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        # Test with zero burn rate\n        eta_display, _eta_before_block_end = display._calculate_eta_display(snapshot, 1000, 5000, 0.0)\n\n        # Should show \"N/A\" for infinite time\n        assert eta_display == \"N/A\"\n\n    def test_calculate_eta_display_normal(self):\n        \"\"\"Test ETA display with normal burn rate.\"\"\"\n        display = MonitorDisplay()\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        burn_rate = 100.0  # tokens per minute\n\n        eta_display, _eta_before_block_end = display._calculate_eta_display(snapshot, 1000, 5000, burn_rate)\n\n        # Should return a string\n        assert isinstance(eta_display, str)\n        assert len(eta_display) > 0\n\n    def test_get_fallback_tool_data(self):\n        \"\"\"Test getting fallback tool data.\"\"\"\n        # Create snapshot with no tools\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        display = MonitorDisplay()\n\n        # Should return empty tool counts and zero total calls\n        tool_counts, total_calls = display._get_fallback_tool_data(snapshot)\n        assert isinstance(tool_counts, dict)\n        assert isinstance(total_calls, int)\n        assert total_calls == 0\n\n    def test_strip_project_name_multiple_prefixes(self):\n        \"\"\"Test stripping project name with multiple configured prefixes.\"\"\"\n        mock_config = Mock()\n        mock_config.display.project_name_prefixes = [\"prefix1_\", \"prefix2_\", \"prefix3_\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Test first prefix match\n        result = display._strip_project_name(\"prefix1_project\")\n        assert result == \"project\"\n\n        # Test second prefix match\n        result = display._strip_project_name(\"prefix2_another\")\n        assert result == \"another\"\n\n        # Test no prefix match\n        result = display._strip_project_name(\"noprefix_project\")\n        assert result == \"noprefix_project\"\n\n    def test_strip_project_name_empty_config(self):\n        \"\"\"Test stripping project name when config has empty prefixes list.\"\"\"\n        mock_config = Mock()\n        mock_config.display.project_name_prefixes = []\n\n        display = MonitorDisplay(config=mock_config)\n        result = display._strip_project_name(\"test_project\")\n\n        # Should return original name when no prefixes configured\n        assert result == \"test_project\"\n\n    def test_layout_with_tool_usage_enabled(self):\n        \"\"\"Test layout setup when tool usage is enabled in config.\"\"\"\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = True\n\n        display = MonitorDisplay(show_sessions=True, config=mock_config)\n\n        # Should have tool_usage layout section\n        assert display.layout is not None\n\n    def test_layout_with_tool_usage_disabled(self):\n        \"\"\"Test layout setup when tool usage is disabled in config.\"\"\"\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = False\n\n        display = MonitorDisplay(show_sessions=True, config=mock_config)\n\n        # Should still have layout\n        assert display.layout is not None\n"}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_0162pbHbKz4pjujPKFGbWVvS","sessionUpdate":"tool_call_update","status":"completed"}}}
{"jsonrpc":"2.0","id":18,"method":"fs/read_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py"}}
{"jsonrpc":"2.0","id":19,"method":"fs/write_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","content":"\"\"\"\nTests for the display module.\n\"\"\"\n\nfrom datetime import UTC, datetime, timedelta, timezone\nfrom unittest.mock import Mock, patch\n\nimport pytest\nfrom rich.console import Console\nfrom rich.panel import Panel\nfrom rich.table import Table\nfrom rich.text import Text\n\nfrom par_cc_usage.display import MonitorDisplay\nfrom par_cc_usage.enums import DisplayMode\n\n\ndef create_mock_config(display_mode=DisplayMode.COMPACT):\n    \"\"\"Create a mock config with all required fields for P90 functionality.\"\"\"\n    config = Mock()\n    from par_cc_usage.config import DisplayConfig\n    config.display = DisplayConfig(display_mode=display_mode)\n    config.max_cost_encountered = 0.0\n    config.max_tokens_encountered = 0\n    config.max_messages_encountered = 0\n    config.max_unified_block_tokens_encountered = 0\n    config.max_unified_block_messages_encountered = 0\n    config.max_unified_block_cost_encountered = 0.0\n    # Add P90 fields\n    config.p90_unified_block_tokens_encountered = 0\n    config.p90_unified_block_messages_encountered = 0\n    config.p90_unified_block_cost_encountered = 0.0\n    return config\nfrom par_cc_usage.models import Project, Session, TokenBlock, TokenUsage, UsageSnapshot\n\n\nclass TestMonitorDisplay:\n    \"\"\"Test the MonitorDisplay class.\"\"\"\n\n    def test_initialization_default(self):\n        \"\"\"Test MonitorDisplay initialization with defaults.\"\"\"\n        display = MonitorDisplay()\n\n        assert display.console is not None\n        assert display.layout is not None\n        assert display.show_sessions is False\n        assert display.time_format == \"24h\"\n\n    def test_initialization_with_params(self):\n        \"\"\"Test MonitorDisplay initialization with parameters.\"\"\"\n        console = Console()\n        display = MonitorDisplay(console=console, show_sessions=True, time_format=\"12h\")\n\n        assert display.console == console\n        assert display.show_sessions is True\n        assert display.time_format == \"12h\"\n\n    def test_initialization_with_compact_mode(self):\n        \"\"\"Test MonitorDisplay initialization with compact mode.\"\"\"\n\n        # Create config with compact mode\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config)\n\n        assert display.compact_mode is True\n        assert display.config == config\n\n    def test_initialization_with_normal_mode(self):\n        \"\"\"Test MonitorDisplay initialization with normal mode.\"\"\"\n\n        # Create config with normal mode\n        config = create_mock_config(DisplayMode.NORMAL)\n        display = MonitorDisplay(config=config)\n\n        assert display.compact_mode is False\n        assert display.config == config\n\n    def test_initialization_without_config(self):\n        \"\"\"Test MonitorDisplay initialization without config defaults to normal mode.\"\"\"\n        display = MonitorDisplay()\n\n        assert display.compact_mode is False\n        assert display.config is None\n\n    def test_setup_layout_without_sessions(self):\n        \"\"\"Test layout setup without sessions panel.\"\"\"\n        display = MonitorDisplay(show_sessions=False)\n\n        # Check layout structure\n        assert display.layout is not None\n        # The layout should have been split\n\n    def test_setup_layout_with_sessions(self):\n        \"\"\"Test layout setup with sessions panel.\"\"\"\n        display = MonitorDisplay(show_sessions=True)\n\n        # Check layout structure\n        assert display.layout is not None\n        # The layout should have sessions panel\n\n    def test_setup_layout_compact_mode(self):\n        \"\"\"Test layout setup in compact mode.\"\"\"\n\n        # Create config with compact mode\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config, show_sessions=True)\n\n        # Check layout structure - should only have header and progress\n        assert display.layout is not None\n        assert display.compact_mode is True\n        # In compact mode, sessions should not be shown even if requested\n\n    def test_setup_layout_compact_mode_without_sessions(self):\n        \"\"\"Test layout setup in compact mode without sessions.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config, show_sessions=False)\n\n        assert display.layout is not None\n        assert display.compact_mode is True\n\n    def test_create_header(self, sample_usage_snapshot):\n        \"\"\"Test header panel creation.\"\"\"\n        display = MonitorDisplay()\n\n        # Create header panel\n        panel = display._create_header(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        # Check that it contains expected header information\n        assert \"Active Projects\" in str(panel.renderable) or \"projects\" in str(panel.renderable).lower()\n\n    def test_create_block_progress_no_unified_block(self):\n        \"\"\"Test block progress panel when no unified block.\"\"\"\n        display = MonitorDisplay()\n\n        # Create snapshot without unified block\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={},\n            total_limit=None,\n        )\n\n        panel = display._create_block_progress(snapshot)\n\n        assert isinstance(panel, Panel)\n\n    def test_create_block_progress_with_block(self, sample_usage_snapshot):\n        \"\"\"Test block progress panel with active block.\"\"\"\n        display = MonitorDisplay()\n\n        # Mock unified block start time by setting block_start_override\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=2)\n\n        panel = display._create_block_progress(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        # The block progress panel doesn't have a title, it just contains the progress bar\n        # We can check that it has the right structure instead\n        assert panel.title is None\n\n    @pytest.mark.asyncio\n    async def test_create_progress_bars(self, sample_usage_snapshot):\n        \"\"\"Test progress bars creation.\"\"\"\n        display = MonitorDisplay()\n\n        panel = await display._create_progress_bars(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Token Usage by Model\"\n\n    @pytest.mark.asyncio\n    async def test_create_progress_bars_compact_mode(self, sample_usage_snapshot):\n        \"\"\"Test progress bars creation in compact mode.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config)\n\n        panel = await display._create_progress_bars(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Token Usage by Model\"\n        # In compact mode, should not show traditional progress bars\n\n    def test_create_model_displays_compact_mode(self):\n        \"\"\"Test model displays in compact mode.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config)\n\n        model_tokens = {\"claude-3-5-sonnet\": 1000, \"claude-3-opus\": 500}\n\n        displays = display._create_model_displays(model_tokens)\n\n        assert len(displays) == 2\n        for display_text in displays:\n            assert isinstance(display_text, Text)\n\n    def test_create_model_displays_normal_mode(self):\n        \"\"\"Test model displays in normal mode.\"\"\"\n\n        config = create_mock_config(DisplayMode.NORMAL)\n        display = MonitorDisplay(config=config)\n\n        model_tokens = {\"claude-3-5-sonnet\": 1000}\n\n        displays = display._create_model_displays(model_tokens)\n\n        assert len(displays) == 1\n        display_text = displays[0]\n        assert isinstance(display_text, Text)\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_no_sessions(self):\n        \"\"\"Test sessions table with no active sessions.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create empty snapshot\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={},\n            total_limit=None,\n        )\n\n        panel = await display._create_sessions_table(snapshot)\n\n        assert isinstance(panel, Panel)\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_with_sessions(self, sample_usage_snapshot):\n        \"\"\"Test sessions table with active sessions.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        panel = await display._create_sessions_table(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n\n    def test_update_with_compact_mode(self, sample_usage_snapshot):\n        \"\"\"Test update method in compact mode only updates essential elements.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)  # Add max_cost_encountered attribute\n\n        display = MonitorDisplay(config=config)\n\n        # Create a proper mock layout that supports item assignment\n        mock_layout = {}\n        display.layout = mock_layout\n\n        # The update method expects certain layout keys to exist\n        mock_layout[\"header\"] = Mock()\n        mock_layout[\"progress\"] = Mock()\n        mock_layout[\"block_progress\"] = Mock()\n        mock_layout[\"tool_usage\"] = Mock()\n        mock_layout[\"sessions\"] = Mock()\n\n        # Update should work in compact mode\n        display.update(sample_usage_snapshot)\n\n        # Verify that layout updates were called\n        assert mock_layout[\"header\"].update.called\n        assert mock_layout[\"progress\"].update.called\n\n    def test_format_time_24h(self):\n        \"\"\"Test time formatting in 24-hour format.\"\"\"\n        from par_cc_usage.utils import format_time\n\n        test_time = datetime(2024, 7, 8, 14, 30, 45, tzinfo=UTC)\n        formatted = format_time(test_time, \"24h\")\n\n        # Should contain 24-hour formatted time\n        assert \"14:30\" in formatted\n\n    def test_format_time_12h(self):\n        \"\"\"Test time formatting in 12-hour format.\"\"\"\n        from par_cc_usage.utils import format_time\n\n        test_time = datetime(2024, 7, 8, 14, 30, 45, tzinfo=UTC)\n        formatted = format_time(test_time, \"12h\")\n\n        # Should contain 12-hour formatted time\n        assert \"PM\" in formatted or \"AM\" in formatted\n\n    def test_compact_mode_hides_sessions_even_when_requested(self):\n        \"\"\"Test that compact mode hides sessions even when show_sessions=True.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        # Request sessions to be shown, but compact mode should override\n        display = MonitorDisplay(config=config, show_sessions=True)\n\n        assert display.compact_mode is True\n        assert display.show_sessions is True  # The setting is preserved\n        # But in compact mode, sessions should not be displayed in the layout\n\n    @pytest.mark.asyncio\n    async def test_compact_mode_burn_rate_calculation(self, sample_usage_snapshot):\n        \"\"\"Test burn rate calculation and display in compact mode.\"\"\"\n\n        config = create_mock_config(DisplayMode.COMPACT)\n        display = MonitorDisplay(config=config)\n\n        # Create progress bars panel which includes burn rate in compact mode\n        panel = await display._create_progress_bars(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        # Compact mode should still show burn rate metrics\n\n    def test_update_display(self, sample_usage_snapshot):\n        \"\"\"Test display update.\"\"\"\n        display = MonitorDisplay()\n\n        # Should not raise an error\n        display.update(sample_usage_snapshot)\n\n    def test_get_model_emoji(self):\n        \"\"\"Test model emoji mapping.\"\"\"\n        display = MonitorDisplay()\n\n        # Test known models - use correct emojis\n        assert display._get_model_emoji(\"opus\") == \"ðŸš€\"\n        assert display._get_model_emoji(\"sonnet\") == \"âš¡\"\n        assert display._get_model_emoji(\"haiku\") == \"ðŸ’¨\"\n        assert display._get_model_emoji(\"claude\") == \"ðŸ¤–\"\n        assert display._get_model_emoji(\"gpt\") == \"ðŸ§ \"\n        assert display._get_model_emoji(\"llama\") == \"ðŸ¦™\"\n        assert display._get_model_emoji(\"unknown\") == \"â“\"\n\n    def test_create_model_displays(self):\n        \"\"\"Test model display creation.\"\"\"\n        display = MonitorDisplay()\n\n        model_tokens = {\n            \"opus\": 50000,\n            \"sonnet\": 30000,\n            \"haiku\": 20000\n        }\n\n        displays = display._create_model_displays(model_tokens)\n\n        assert isinstance(displays, list)\n        assert len(displays) == 3\n        # Should be sorted alphabetically by model name\n        display_strs = [str(display) for display in displays]\n        assert any(\"Haiku\" in d for d in display_strs)\n        assert any(\"Opus\" in d for d in display_strs)\n        assert any(\"Sonnet\" in d for d in display_strs)\n\n    def test_get_progress_colors(self):\n        \"\"\"Test progress color determination.\"\"\"\n        display = MonitorDisplay()\n\n        # Test different usage levels - use percentage as 0-100 range\n        bar_color, _text_color = display._get_progress_colors(30, 30000, 100000)\n        # Should be green for low usage (30%)\n        assert \"00FF00\" in bar_color\n\n        bar_color, _text_color = display._get_progress_colors(80, 80000, 100000)\n        # Should be orange for medium usage (80%)\n        assert \"FFA500\" in bar_color\n\n        bar_color, _text_color = display._get_progress_colors(95, 95000, 100000)\n        # Should be red for high usage (95%)\n        assert \"FF0000\" in bar_color\n\n    def test_calculate_burn_rate(self, sample_usage_snapshot):\n        \"\"\"Test burn rate calculation text creation.\"\"\"\n        display = MonitorDisplay()\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        text = display._calculate_burn_rate_sync(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n\n    @pytest.mark.asyncio\n    async def test_calculate_burn_rate_async_without_pricing(self, sample_usage_snapshot):\n        \"\"\"Test async burn rate calculation without pricing enabled.\"\"\"\n        # Mock config without pricing\n        mock_config = Mock()\n        mock_config.display.show_pricing = False\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        text = await display._calculate_burn_rate(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n        assert \"$\" not in text.plain  # Should not have estimated cost when pricing disabled\n\n    @pytest.mark.asyncio\n    async def test_calculate_burn_rate_async_with_pricing(self, sample_usage_snapshot):\n        \"\"\"Test async burn rate calculation with pricing enabled.\"\"\"\n        # Mock config with pricing enabled\n        mock_config = Mock()\n        mock_config.display.show_pricing = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        # Mock the get_unified_block_total_cost method to return a test cost\n        async def mock_get_cost():\n            return 10.50  # $10.50 current cost\n        sample_usage_snapshot.get_unified_block_total_cost = mock_get_cost\n\n        text = await display._calculate_burn_rate(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n        # Should have estimated cost when pricing enabled and cost available\n        assert \"Est:\" in text.plain and \"$\" in text.plain\n\n    @pytest.mark.asyncio\n    async def test_calculate_burn_rate_async_pricing_error(self, sample_usage_snapshot):\n        \"\"\"Test async burn rate calculation when pricing calculation fails.\"\"\"\n        # Mock config with pricing enabled\n        mock_config = Mock()\n        mock_config.display.show_pricing = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        # Mock the get_unified_block_total_cost method to raise an exception\n        async def mock_get_cost_error():\n            raise Exception(\"Pricing calculation failed\")\n        sample_usage_snapshot.get_unified_block_total_cost = mock_get_cost_error\n\n        text = await display._calculate_burn_rate(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n        # Should not break when pricing fails - graceful degradation\n\n    @pytest.mark.asyncio\n    async def test_calculate_burn_rate_async_zero_cost(self, sample_usage_snapshot):\n        \"\"\"Test async burn rate calculation with zero cost.\"\"\"\n        # Mock config with pricing enabled\n        mock_config = Mock()\n        mock_config.display.show_pricing = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Mock timestamp for consistent elapsed time\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        # Mock the get_unified_block_total_cost method to return zero cost\n        async def mock_get_zero_cost():\n            return 0.0\n        sample_usage_snapshot.get_unified_block_total_cost = mock_get_zero_cost\n\n        text = await display._calculate_burn_rate(sample_usage_snapshot, 60000, 100000)\n\n        assert hasattr(text, 'plain')  # Should be a Text object\n        assert \"/m\" in text.plain  # Abbreviated tokens per minute format\n        # Should not show cost estimate when cost is zero\n\n    def test_calculate_eta_display(self, sample_usage_snapshot):\n        \"\"\"Test ETA display calculation.\"\"\"\n        display = MonitorDisplay()\n\n        # Mock values for ETA calculation\n        sample_usage_snapshot.timestamp = datetime.now(UTC)\n        sample_usage_snapshot.block_start_override = datetime.now(UTC) - timedelta(hours=1)\n\n        eta_result = display._calculate_eta_display(sample_usage_snapshot, 50000, 100000, 833.33)  # 50k tokens/hour rate\n\n        assert isinstance(eta_result, tuple)  # Should be a tuple\n        assert len(eta_result) == 2  # (display_string, eta_before_block_end)\n        display_string, eta_before_block_end = eta_result\n        assert isinstance(display_string, str)\n        assert isinstance(eta_before_block_end, bool)\n\n    @patch('par_cc_usage.display.Live')\n    def test_live_context_manager(self, mock_live_class, sample_usage_snapshot):\n        \"\"\"Test using display update method.\"\"\"\n        mock_live = Mock()\n        mock_live_class.return_value = mock_live\n\n        display = MonitorDisplay()\n\n        # Just test that update method works\n        display.update(sample_usage_snapshot)\n\n        # The update method should work without errors\n        assert True\n\n    @pytest.mark.asyncio\n    async def test_create_progress_bars_with_limit(self, sample_usage_snapshot):\n        \"\"\"Test progress bars with token limit set.\"\"\"\n        display = MonitorDisplay()\n\n        # Set a token limit\n        sample_usage_snapshot.total_limit = 100000\n\n        panel = await display._create_progress_bars(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Token Usage by Model\"\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_with_unified_block(self, sample_usage_snapshot):\n        \"\"\"Test sessions table filtering by unified block.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Set unified block time\n        block_start = datetime.now(UTC) - timedelta(hours=2)\n        sample_usage_snapshot.block_start_override = block_start\n\n        # Ensure the session's block matches\n        for project in sample_usage_snapshot.projects.values():\n            for session in project.sessions.values():\n                for block in session.blocks:\n                    block.start_time = block_start\n\n        panel = await display._create_sessions_table(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n\n    def test_create_header_with_no_limit(self, sample_usage_snapshot):\n        \"\"\"Test header creation when no token limit is set.\"\"\"\n        display = MonitorDisplay()\n\n        # Remove token limit\n        sample_usage_snapshot.total_limit = None\n\n        panel = display._create_header(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        # Just check that the header is created successfully\n        assert \"Active\" in str(panel.renderable) or \"projects\" in str(panel.renderable).lower()\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_project_aggregation_mode(self, sample_usage_snapshot):\n        \"\"\"Test sessions table with project aggregation enabled.\"\"\"\n        # Mock config with project aggregation enabled\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n        mock_config.display.show_tool_usage = False  # Disable tool usage for consistent column count\n        mock_config.display.show_pricing = False  # Disable pricing for testing\n\n        display = MonitorDisplay(config=mock_config)\n\n        panel = await display._create_sessions_table(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Projects with Activity in Current Block\"\n\n        # The table should have different columns for project mode\n        table = panel.renderable\n        assert isinstance(table, Table)\n        # Check that it has the expected columns for project aggregation (Project, Model, Tokens, Messages)\n        assert len(table.columns) == 4  # Project, Model, Tokens, Messages\n\n    @pytest.mark.asyncio\n    async def test_create_sessions_table_session_aggregation_mode(self, sample_usage_snapshot):\n        \"\"\"Test sessions table with session aggregation enabled.\"\"\"\n        # Mock config with project aggregation disabled\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n        mock_config.display.project_name_prefixes = [\"-Users-\", \"-home-\"]\n        mock_config.display.show_tool_usage = False  # Disable tool usage for consistent column count\n        mock_config.display.show_pricing = False  # Disable pricing for testing\n\n        display = MonitorDisplay(config=mock_config)\n\n        panel = await display._create_sessions_table(sample_usage_snapshot)\n\n        assert isinstance(panel, Panel)\n        assert panel.title == \"Sessions with Activity in Current Block\"\n\n        # The table should have different columns for session mode\n        table = panel.renderable\n        assert isinstance(table, Table)\n        # Check that it has the expected columns for session aggregation (Project, Session ID, Model, Tokens, Messages)\n        assert len(table.columns) == 5  # Project, Session ID, Model, Tokens, Messages\n\n    def test_strip_project_name_with_config(self):\n        \"\"\"Test project name stripping with configuration.\"\"\"\n        mock_config = Mock()\n        mock_config.display.project_name_prefixes = [\"-Users-johndoe-\", \"-home-\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Test prefix stripping\n        assert display._strip_project_name(\"-Users-johndoe-MyProject\") == \"MyProject\"\n        assert display._strip_project_name(\"-home-MyProject\") == \"MyProject\"\n        assert display._strip_project_name(\"MyProject\") == \"MyProject\"  # No prefix to strip\n\n    def test_strip_project_name_no_config(self):\n        \"\"\"Test project name stripping without configuration.\"\"\"\n        display = MonitorDisplay(config=None)\n\n        # Without config, should return original name\n        assert display._strip_project_name(\"-Users-johndoe-MyProject\") == \"-Users-johndoe-MyProject\"\n        assert display._strip_project_name(\"MyProject\") == \"MyProject\"\n\n    def test_strip_project_name_empty_prefixes(self):\n        \"\"\"Test project name stripping with empty prefixes.\"\"\"\n        mock_config = Mock()\n        mock_config.display.project_name_prefixes = []\n\n        display = MonitorDisplay(config=mock_config)\n\n        # With empty prefixes, should return original name\n        assert display._strip_project_name(\"-Users-johndoe-MyProject\") == \"-Users-johndoe-MyProject\"\n        assert display._strip_project_name(\"MyProject\") == \"MyProject\"\n\n    @pytest.mark.asyncio\n    async def test_populate_project_table(self, sample_usage_snapshot):\n        \"\"\"Test populating table with project aggregation data.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n        mock_config.display.project_name_prefixes = [\"-Users-\"]\n        mock_config.display.show_tool_usage = False  # Disable tool usage for consistent column count\n        mock_config.display.show_pricing = False  # Disable pricing for testing\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create a table to populate\n        table = Table()\n\n        # Mock the project methods\n        project = next(iter(sample_usage_snapshot.projects.values()))\n        project.get_unified_block_tokens = Mock(return_value=5000)\n        project.get_unified_block_models = Mock(return_value={\"claude-3-5-sonnet-latest\", \"claude-3-opus-latest\"})\n        project.get_unified_block_latest_activity = Mock(return_value=datetime.now(UTC))\n\n        # Call the method\n        await display._populate_project_table(table, sample_usage_snapshot, None)\n\n        # Verify the table was populated\n        assert len(table.columns) == 4  # Project, Model, Tokens, Messages\n        assert table.row_count >= 0  # Should have at least attempted to add rows\n\n    @pytest.mark.asyncio\n    async def test_populate_session_table(self, sample_usage_snapshot):\n        \"\"\"Test populating table with session aggregation data.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n        mock_config.display.project_name_prefixes = [\"-Users-\"]\n        mock_config.display.show_tool_usage = False  # Disable tool usage for consistent column count\n        mock_config.display.show_pricing = False  # Disable pricing for testing\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create a table to populate\n        table = Table()\n\n        # Call the method\n        await display._populate_session_table(table, sample_usage_snapshot, None)\n\n        # Verify the table was populated\n        assert len(table.columns) == 5  # Project, Session ID, Model, Tokens, Messages\n        assert table.row_count >= 0  # Should have at least attempted to add rows\n\n    def test_calculate_session_data(self, sample_usage_snapshot):\n        \"\"\"Test calculating session data for aggregation.\"\"\"\n        # Mock config\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Get a session from the snapshot\n        project = next(iter(sample_usage_snapshot.projects.values()))\n        session = next(iter(project.sessions.values()))\n\n        # Call the method - now returns 5 values\n        session_tokens, session_models, session_latest_activity, session_tools, session_tool_calls = display._calculate_session_data(session, None)\n\n        # Verify the results\n        assert isinstance(session_tokens, int)\n        assert isinstance(session_models, set)\n        assert session_latest_activity is None or isinstance(session_latest_activity, datetime)\n        assert isinstance(session_tools, set)\n        assert isinstance(session_tool_calls, int)\n\n    def test_should_include_block_no_unified_start(self):\n        \"\"\"Test block inclusion logic without unified start time.\"\"\"\n        display = MonitorDisplay()\n\n        # Mock active block\n        mock_block = Mock()\n        mock_block.is_active = True\n\n        # With no unified start, active blocks should be included\n        assert display._should_include_block(mock_block, None) is True\n\n        # Inactive blocks should not be included\n        mock_block.is_active = False\n        assert display._should_include_block(mock_block, None) is False\n\n    def test_should_include_block_with_unified_start(self):\n        \"\"\"Test block inclusion logic with unified start time.\"\"\"\n        display = MonitorDisplay()\n\n        unified_start = datetime.now(UTC)\n\n        # Mock active block that overlaps with unified window\n        mock_block = Mock()\n        mock_block.is_active = True\n        mock_block.start_time = unified_start - timedelta(hours=1)  # Starts before unified block ends\n        mock_block.actual_end_time = unified_start + timedelta(hours=1)  # Ends after unified block starts\n        mock_block.end_time = unified_start + timedelta(hours=4)\n\n        # Should be included (overlaps with unified window)\n        assert display._should_include_block(mock_block, unified_start) is True\n\n        # Mock block that doesn't overlap\n        mock_block.start_time = unified_start + timedelta(hours=6)  # Starts after unified block ends\n        mock_block.actual_end_time = unified_start + timedelta(hours=7)\n        mock_block.end_time = unified_start + timedelta(hours=11)\n\n        # Should not be included (no overlap)\n        assert display._should_include_block(mock_block, unified_start) is False\n\n    def test_add_empty_row_if_needed_project_mode(self):\n        \"\"\"Test adding empty row in project aggregation mode.\"\"\"\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create empty table\n        table = Table()\n        table.add_column(\"Project\")\n        table.add_column(\"Model\")\n        table.add_column(\"Tokens\")\n\n        # Add empty row\n        display._add_empty_row_if_needed(table)\n\n        # Should have added one row\n        assert table.row_count == 1\n\n    def test_add_empty_row_if_needed_session_mode(self):\n        \"\"\"Test adding empty row in session aggregation mode.\"\"\"\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Create empty table\n        table = Table()\n        table.add_column(\"Project\")\n        table.add_column(\"Session ID\")\n        table.add_column(\"Model\")\n        table.add_column(\"Tokens\")\n\n        # Add empty row\n        display._add_empty_row_if_needed(table)\n\n        # Should have added one row\n        assert table.row_count == 1\n\n    def test_get_table_title_project_mode(self):\n        \"\"\"Test getting table title for project aggregation mode.\"\"\"\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = True\n\n        display = MonitorDisplay(config=mock_config)\n\n        title = display._get_table_title()\n        assert title == \"Projects with Activity in Current Block\"\n\n    def test_get_table_title_session_mode(self):\n        \"\"\"Test getting table title for session aggregation mode.\"\"\"\n        mock_config = Mock()\n        mock_config.display.aggregate_by_project = False\n\n        display = MonitorDisplay(config=mock_config)\n\n        title = display._get_table_title()\n        assert title == \"Sessions with Activity in Current Block\"\n\n\nclass TestMonitorDisplayEdgeCases:\n    \"\"\"Test edge cases and missing coverage for MonitorDisplay.\"\"\"\n\n    def test_block_progress_with_timezone_mismatch(self):\n        \"\"\"Test block progress when unified block and current time have different timezones.\"\"\"\n        from datetime import timedelta\n\n        # Create snapshot with UTC time\n        utc_time = datetime.now(UTC)\n\n        # Create a token usage and block\n        token_usage = TokenUsage(\n            input_tokens=100,\n            output_tokens=50,\n            model=\"claude-3-5-sonnet-latest\"\n        )\n\n        # Create block with a different timezone (EST)\n        est_tz = timezone(timedelta(hours=-5))\n        block_start = utc_time.replace(tzinfo=est_tz)\n\n        block = TokenBlock(\n            start_time=block_start,\n            end_time=block_start + timedelta(hours=1),\n            session_id=\"session_1\",\n            project_name=\"project_1\",\n            model=\"claude-3-5-sonnet-latest\",\n            token_usage=token_usage,\n            models_used={\"claude-3-5-sonnet-latest\"}\n        )\n\n        session = Session(\n            session_id=\"session_1\",\n            project_name=\"project_1\",\n            model=\"claude-3-5-sonnet-latest\"\n        )\n        session.blocks = [block]\n\n        project = Project(name=\"project_1\")\n        project.sessions = {\"session_1\": session}\n\n        # Override the unified block start time to trigger timezone conversion\n        snapshot = UsageSnapshot(\n            timestamp=utc_time,\n            projects={\"project_1\": project}\n        )\n        snapshot.block_start_override = block_start\n\n        display = MonitorDisplay()\n        result = display._create_block_progress(snapshot)\n\n        # Should not raise an error and should return a Panel\n        assert isinstance(result, Panel)\n\n    def test_get_model_emoji_all_types(self):\n        \"\"\"Test model emoji for all supported model types.\"\"\"\n        display = MonitorDisplay()\n\n        # Test all specific model types\n        assert display._get_model_emoji(\"claude-3-opus-latest\") == \"ðŸš€\"\n        assert display._get_model_emoji(\"claude-3-sonnet-latest\") == \"âš¡\"\n        assert display._get_model_emoji(\"claude-3-haiku-latest\") == \"ðŸ’¨\"\n        assert display._get_model_emoji(\"claude-2\") == \"ðŸ¤–\"\n        assert display._get_model_emoji(\"gpt-4\") == \"ðŸ§ \"\n        assert display._get_model_emoji(\"llama-2\") == \"ðŸ¦™\"\n        assert display._get_model_emoji(\"unknown-model\") == \"â“\"\n\n    def test_get_progress_colors_all_ranges(self):\n        \"\"\"Test progress colors for all percentage ranges.\"\"\"\n        display = MonitorDisplay()\n\n        # Test low usage (< 50%) - green (now includes color in style)\n        bar_color, text_style = display._get_progress_colors(25.0, 25000, 100000)\n        assert bar_color == \"#00FF00\"\n        assert text_style == \"bold #00FF00\"  # Now includes color with theme system\n\n        # Test medium usage (50-75%) - yellow\n        bar_color, text_style = display._get_progress_colors(60.0, 60000, 100000)\n        assert bar_color == \"#FFFF00\"\n        assert text_style == \"bold #FFFF00\"\n\n        # Test high usage (75-90%) - orange\n        bar_color, text_style = display._get_progress_colors(80.0, 80000, 100000)\n        assert bar_color == \"#FFA500\"\n        assert text_style == \"bold #FFA500\"\n\n        # Test very high usage (> 90%) - red (uses get_style for critical)\n        bar_color, text_style = display._get_progress_colors(95.0, 95000, 100000)\n        assert bar_color == \"#FF0000\"\n        assert text_style == \"#FF0000 bold\"  # get_style puts color first\n\n    def test_create_tool_usage_table_with_tools(self):\n        \"\"\"Test tool usage table creation when tools are used.\"\"\"\n        # Create snapshot with tool usage\n        now = datetime.now(UTC)\n\n        token_usage = TokenUsage(\n            input_tokens=100,\n            output_tokens=50,\n            model=\"claude-3-5-sonnet-latest\",\n            tools_used=[\"Read\", \"Edit\", \"Bash\"],\n            tool_use_count=5\n        )\n\n        block = TokenBlock(\n            start_time=now,\n            end_time=now + timedelta(hours=1),\n            session_id=\"session_1\",\n            project_name=\"project_1\",\n            model=\"claude-3-5-sonnet-latest\",\n            token_usage=token_usage,\n            models_used={\"claude-3-5-sonnet-latest\"},\n            tools_used={\"Read\", \"Edit\", \"Bash\"},\n            total_tool_calls=5,\n            tool_call_counts={\"Read\": 2, \"Edit\": 2, \"Bash\": 1}\n        )\n\n        session = Session(\n            session_id=\"session_1\",\n            project_name=\"project_1\",\n            model=\"claude-3-5-sonnet-latest\"\n        )\n        session.blocks = [block]\n\n        project = Project(name=\"project_1\")\n        project.sessions = {\"session_1\": session}\n\n        snapshot = UsageSnapshot(\n            timestamp=now,\n            projects={\"project_1\": project}\n        )\n\n        # Mock config to enable tool usage display\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = True\n\n        display = MonitorDisplay(config=mock_config)\n        result = display._create_tool_usage_table(snapshot)\n\n        # Should return a Table\n        assert isinstance(result, Table)\n\n    def test_create_tool_usage_table_disabled(self):\n        \"\"\"Test tool usage table when disabled in config.\"\"\"\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        # Mock config to disable tool usage display\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = False\n\n        display = MonitorDisplay(config=mock_config)\n        result = display._create_tool_usage_table(snapshot)\n\n        # Should return a Table even when disabled, but empty\n        assert isinstance(result, Table)\n\n    def test_create_tool_usage_table_no_config(self):\n        \"\"\"Test tool usage table with no config.\"\"\"\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        display = MonitorDisplay(config=None)\n        result = display._create_tool_usage_table(snapshot)\n\n        # Should return a Table even when no config, but empty\n        assert isinstance(result, Table)\n\n    def test_create_tool_usage_table_empty_tools(self):\n        \"\"\"Test tool usage table with no tools used.\"\"\"\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        # Mock config to enable tool usage display\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = True\n\n        display = MonitorDisplay(config=mock_config)\n        result = display._create_tool_usage_table(snapshot)\n\n        # Should return a Table even with empty tools\n        assert isinstance(result, Table)\n\n    def test_calculate_burn_rate_no_block(self):\n        \"\"\"Test burn rate calculation with no active block.\"\"\"\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        display = MonitorDisplay()\n\n        # Should handle no active block gracefully and return Text\n        burn_rate_text = display._calculate_burn_rate_sync(snapshot, 1000, 5000)\n        assert isinstance(burn_rate_text, Text)\n\n    def test_calculate_eta_display_infinite(self):\n        \"\"\"Test ETA display when burn rate is zero (infinite time).\"\"\"\n        display = MonitorDisplay()\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        # Test with zero burn rate\n        eta_display, _eta_before_block_end = display._calculate_eta_display(snapshot, 1000, 5000, 0.0)\n\n        # Should show \"N/A\" for infinite time\n        assert eta_display == \"N/A\"\n\n    def test_calculate_eta_display_normal(self):\n        \"\"\"Test ETA display with normal burn rate.\"\"\"\n        display = MonitorDisplay()\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        burn_rate = 100.0  # tokens per minute\n\n        eta_display, _eta_before_block_end = display._calculate_eta_display(snapshot, 1000, 5000, burn_rate)\n\n        # Should return a string\n        assert isinstance(eta_display, str)\n        assert len(eta_display) > 0\n\n    def test_get_fallback_tool_data(self):\n        \"\"\"Test getting fallback tool data.\"\"\"\n        # Create snapshot with no tools\n        snapshot = UsageSnapshot(\n            timestamp=datetime.now(UTC),\n            projects={}\n        )\n\n        display = MonitorDisplay()\n\n        # Should return empty tool counts and zero total calls\n        tool_counts, total_calls = display._get_fallback_tool_data(snapshot)\n        assert isinstance(tool_counts, dict)\n        assert isinstance(total_calls, int)\n        assert total_calls == 0\n\n    def test_strip_project_name_multiple_prefixes(self):\n        \"\"\"Test stripping project name with multiple configured prefixes.\"\"\"\n        mock_config = Mock()\n        mock_config.display.project_name_prefixes = [\"prefix1_\", \"prefix2_\", \"prefix3_\"]\n\n        display = MonitorDisplay(config=mock_config)\n\n        # Test first prefix match\n        result = display._strip_project_name(\"prefix1_project\")\n        assert result == \"project\"\n\n        # Test second prefix match\n        result = display._strip_project_name(\"prefix2_another\")\n        assert result == \"another\"\n\n        # Test no prefix match\n        result = display._strip_project_name(\"noprefix_project\")\n        assert result == \"noprefix_project\"\n\n    def test_strip_project_name_empty_config(self):\n        \"\"\"Test stripping project name when config has empty prefixes list.\"\"\"\n        mock_config = Mock()\n        mock_config.display.project_name_prefixes = []\n\n        display = MonitorDisplay(config=mock_config)\n        result = display._strip_project_name(\"test_project\")\n\n        # Should return original name when no prefixes configured\n        assert result == \"test_project\"\n\n    def test_layout_with_tool_usage_enabled(self):\n        \"\"\"Test layout setup when tool usage is enabled in config.\"\"\"\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = True\n\n        display = MonitorDisplay(show_sessions=True, config=mock_config)\n\n        # Should have tool_usage layout section\n        assert display.layout is not None\n\n    def test_layout_with_tool_usage_disabled(self):\n        \"\"\"Test layout setup when tool usage is disabled in config.\"\"\"\n        mock_config = Mock()\n        mock_config.display.show_tool_usage = False\n\n        display = MonitorDisplay(show_sessions=True, config=mock_config)\n\n        # Should still have layout\n        assert display.layout is not None\n"}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01Uu23uSvK2HvWzSoinJC8LD","sessionUpdate":"tool_call_update","status":"completed"}}}
{"jsonrpc":"2.0","id":20,"method":"fs/read_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_utils.py"}}
{"jsonrpc":"2.0","id":21,"method":"fs/write_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_utils.py","content":"\"\"\"\nTests for the utils module.\n\"\"\"\n\nimport os\nfrom datetime import UTC, datetime\nfrom pathlib import Path\nfrom unittest.mock import patch\nfrom zoneinfo import ZoneInfo\n\nfrom par_cc_usage.token_calculator import format_token_count\nfrom par_cc_usage.utils import (\n    detect_system_timezone,\n    ensure_directory,\n    expand_path,\n    format_bytes,\n    format_datetime,\n    format_time,\n    format_time_range,\n)\n\n\nclass TestExpandPath:\n    \"\"\"Test path expansion functionality.\"\"\"\n\n    def test_expand_home_directory(self):\n        \"\"\"Test expanding ~ in paths.\"\"\"\n        path = \"~/Documents/test.txt\"\n        result = expand_path(path)\n\n        assert isinstance(result, Path)\n        assert \"~\" not in str(result)\n        assert str(result).startswith(str(Path.home()))\n\n    def test_expand_environment_variables(self):\n        \"\"\"Test expanding environment variables in paths.\"\"\"\n        with patch.dict(os.environ, {\"TEST_DIR\": \"/custom/path\", \"USER\": \"testuser\"}):\n            path = \"$TEST_DIR/data/$USER/file.txt\"\n            result = expand_path(path)\n\n            assert str(result) == \"/custom/path/data/testuser/file.txt\"\n\n    def test_expand_complex_path(self):\n        \"\"\"Test expanding path with both ~ and env vars.\"\"\"\n        with patch.dict(os.environ, {\"SUBDIR\": \"projects\"}):\n            path = \"~/$SUBDIR/test\"\n            result = expand_path(path)\n\n            assert isinstance(result, Path)\n            assert \"~\" not in str(result)\n            assert \"$SUBDIR\" not in str(result)\n            assert str(result).endswith(\"projects/test\")\n\n    def test_expand_already_absolute_path(self):\n        \"\"\"Test that absolute paths are returned as Path objects.\"\"\"\n        path = \"/usr/local/bin/test\"\n        result = expand_path(path)\n\n        assert isinstance(result, Path)\n        assert str(result) == path\n\n    def test_expand_relative_path(self):\n        \"\"\"Test that relative paths are converted to Path objects.\"\"\"\n        path = \"./data/file.txt\"\n        result = expand_path(path)\n\n        assert isinstance(result, Path)\n        # Result should be a Path object representation of the relative path\n        assert result == Path(path)\n\n    def test_expand_path_object(self):\n        \"\"\"Test expanding Path object.\"\"\"\n        path = Path(\"~/test\")\n        result = expand_path(path)\n\n        assert isinstance(result, Path)\n        assert \"~\" not in str(result)\n\n\nclass TestEnsureDirectory:\n    \"\"\"Test directory creation functionality.\"\"\"\n\n    def test_create_new_directory(self, tmp_path):\n        \"\"\"Test creating a new directory.\"\"\"\n        test_dir = tmp_path / \"new_directory\"\n        assert not test_dir.exists()\n\n        ensure_directory(test_dir)\n\n        assert test_dir.exists()\n        assert test_dir.is_dir()\n\n    def test_existing_directory(self, tmp_path):\n        \"\"\"Test that existing directory is not recreated.\"\"\"\n        test_dir = tmp_path / \"existing\"\n        test_dir.mkdir()\n\n        # Create a file to verify directory isn't recreated\n        test_file = test_dir / \"test.txt\"\n        test_file.write_text(\"content\")\n\n        ensure_directory(test_dir)\n\n        # Directory and contents should still exist\n        assert test_dir.exists()\n        assert test_file.exists()\n        assert test_file.read_text() == \"content\"\n\n    def test_create_nested_directories(self, tmp_path):\n        \"\"\"Test creating nested directory structure.\"\"\"\n        test_dir = tmp_path / \"level1\" / \"level2\" / \"level3\"\n        assert not test_dir.exists()\n\n        ensure_directory(test_dir)\n\n        assert test_dir.exists()\n        assert test_dir.is_dir()\n\n\nclass TestFormatBytes:\n    \"\"\"Test byte formatting functionality.\"\"\"\n\n    def test_format_bytes_small(self):\n        \"\"\"Test formatting small byte values.\"\"\"\n        assert format_bytes(0) == \"0.0 B\"\n        assert format_bytes(1) == \"1.0 B\"\n        assert format_bytes(999) == \"999.0 B\"\n\n    def test_format_kilobytes(self):\n        \"\"\"Test formatting kilobyte values.\"\"\"\n        assert format_bytes(1024) == \"1.0 KB\"\n        assert format_bytes(1536) == \"1.5 KB\"\n        assert format_bytes(2048) == \"2.0 KB\"\n\n    def test_format_megabytes(self):\n        \"\"\"Test formatting megabyte values.\"\"\"\n        assert format_bytes(1024 * 1024) == \"1.0 MB\"\n        assert format_bytes(1024 * 1024 * 1.5) == \"1.5 MB\"\n\n    def test_format_gigabytes(self):\n        \"\"\"Test formatting gigabyte values.\"\"\"\n        assert format_bytes(1024 * 1024 * 1024) == \"1.0 GB\"\n\n    def test_format_terabytes(self):\n        \"\"\"Test formatting terabyte values.\"\"\"\n        assert format_bytes(1024 * 1024 * 1024 * 1024) == \"1.0 TB\"\n\n    def test_format_petabytes(self):\n        \"\"\"Test formatting petabyte values.\"\"\"\n        # After TB, the loop continues to PB\n        assert \"PB\" in format_bytes(1024 * 1024 * 1024 * 1024 * 1024)\n\n\nclass TestFormatTokenCount:\n    \"\"\"Test token count formatting functionality.\"\"\"\n\n    def test_format_small_counts(self):\n        \"\"\"Test formatting small token counts.\"\"\"\n        assert format_token_count(0) == \"0\"\n        assert format_token_count(1) == \"1\"\n        assert format_token_count(999) == \"999\"\n\n    def test_format_thousands(self):\n        \"\"\"Test formatting thousands.\"\"\"\n        assert format_token_count(1000) == \"1K\"\n        assert format_token_count(1500) == \"2K\"  # .0f rounds to nearest int\n        assert format_token_count(9999) == \"10K\"\n\n    def test_format_millions(self):\n        \"\"\"Test formatting millions.\"\"\"\n        assert format_token_count(1000000) == \"1.0M\"\n        assert format_token_count(1500000) == \"1.5M\"\n\n    def test_format_billions(self):\n        \"\"\"Test formatting billions - function treats as millions.\"\"\"\n        assert format_token_count(1000000000) == \"1000.0M\"\n\n\nclass TestFormatTime:\n    \"\"\"Test time formatting functionality.\"\"\"\n\n    def test_format_12h(self):\n        \"\"\"Test 12-hour format.\"\"\"\n        dt = datetime(2025, 1, 9, 14, 30, 45, tzinfo=UTC)\n        assert format_time(dt, time_format=\"12h\") == \"02:30 PM\"\n\n        dt2 = datetime(2025, 1, 9, 0, 0, 0, tzinfo=UTC)\n        assert format_time(dt2, time_format=\"12h\") == \"12:00 AM\"\n\n    def test_format_24h(self):\n        \"\"\"Test 24-hour format.\"\"\"\n        dt = datetime(2025, 1, 9, 14, 30, 45, tzinfo=UTC)\n        assert format_time(dt, time_format=\"24h\") == \"14:30\"\n\n        dt2 = datetime(2025, 1, 9, 0, 0, 0, tzinfo=UTC)\n        assert format_time(dt2, time_format=\"24h\") == \"00:00\"\n\n    def test_format_default(self):\n        \"\"\"Test default format (24h).\"\"\"\n        dt = datetime(2025, 1, 9, 14, 30, 45, tzinfo=UTC)\n        assert format_time(dt) == \"14:30\"\n\n\nclass TestFormatDatetime:\n    \"\"\"Test datetime formatting functionality.\"\"\"\n\n    def test_format_datetime_12h(self):\n        \"\"\"Test datetime formatting with 12-hour time.\"\"\"\n        dt = datetime(2025, 1, 9, 14, 30, 45, tzinfo=UTC)\n        result = format_datetime(dt, time_format=\"12h\")\n\n        assert \"2025-01-09\" in result\n        assert \"02:30:45 PM\" in result\n\n    def test_format_datetime_24h(self):\n        \"\"\"Test datetime formatting with 24-hour time.\"\"\"\n        dt = datetime(2025, 1, 9, 14, 30, 45, tzinfo=UTC)\n        result = format_datetime(dt, time_format=\"24h\")\n\n        assert \"2025-01-09\" in result\n        assert \"14:30:45\" in result\n\n    def test_format_datetime_with_timezone(self):\n        \"\"\"Test datetime formatting includes timezone.\"\"\"\n        tz = ZoneInfo(\"America/Los_Angeles\")\n        dt = datetime(2025, 1, 9, 14, 30, 45, tzinfo=tz)\n\n        result = format_datetime(dt)\n        assert \"PST\" in result or \"PDT\" in result\n\n\nclass TestFormatTimeRange:\n    \"\"\"Test time range formatting functionality.\"\"\"\n\n    def test_format_time_range_12h(self):\n        \"\"\"Test formatting time range with 12h format.\"\"\"\n        start = datetime(2025, 1, 9, 9, 0, 0, tzinfo=UTC)\n        end = datetime(2025, 1, 9, 17, 30, 0, tzinfo=UTC)\n\n        result = format_time_range(start, end, time_format=\"12h\")\n        assert \"09:00 AM\" in result\n        assert \"05:30 PM\" in result\n        assert \"UTC\" in result\n\n    def test_format_time_range_24h(self):\n        \"\"\"Test formatting time range with 24h format.\"\"\"\n        start = datetime(2025, 1, 9, 9, 0, 0, tzinfo=UTC)\n        end = datetime(2025, 1, 9, 17, 30, 0, tzinfo=UTC)\n\n        result = format_time_range(start, end, time_format=\"24h\")\n        assert \"09:00\" in result\n        assert \"17:30\" in result\n        assert \"UTC\" in result\n\n\nclass TestDetectSystemTimezone:\n    \"\"\"Test system timezone detection functionality.\"\"\"\n\n    def test_detect_system_timezone_returns_string(self):\n        \"\"\"Test that detect_system_timezone returns a string.\"\"\"\n        result = detect_system_timezone()\n        assert isinstance(result, str)\n        assert len(result) > 0\n\n    def test_detect_system_timezone_returns_valid_timezone(self):\n        \"\"\"Test that the returned timezone is a valid IANA name or fallback.\"\"\"\n        result = detect_system_timezone()\n\n        # Should be a valid IANA timezone name or the fallback\n        valid_patterns = [\n            \"America/\",\n            \"Europe/\",\n            \"Asia/\",\n            \"Africa/\",\n            \"Australia/\",\n            \"Pacific/\",\n            \"Atlantic/\",\n            \"Indian/\",\n            \"UTC\",\n        ]\n\n        assert any(pattern in result for pattern in valid_patterns), f\"Invalid timezone: {result}\"\n\n    @patch(\"par_cc_usage.utils.datetime\")\n    def test_detect_system_timezone_with_pytz_zone_attribute(self, mock_datetime):\n        \"\"\"Test timezone detection when tzinfo has zone attribute.\"\"\"\n        # Mock timezone object with zone attribute\n        mock_tz = type('MockTZ', (), {})()\n        mock_tz.zone = \"America/New_York\"\n\n        mock_dt = type('MockDT', (), {})()\n        mock_dt.tzinfo = mock_tz\n\n        mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n        result = detect_system_timezone()\n        assert result == \"America/New_York\"\n\n    @patch(\"par_cc_usage.utils.datetime\")\n    def test_detect_system_timezone_with_key_attribute(self, mock_datetime):\n        \"\"\"Test timezone detection when tzinfo has key attribute.\"\"\"\n        # Mock timezone object with key attribute\n        mock_tz = type('MockTZ', (), {})()\n        mock_tz.key = \"Europe/London\"\n\n        mock_dt = type('MockDT', (), {})()\n        mock_dt.tzinfo = mock_tz\n\n        mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n        result = detect_system_timezone()\n        assert result == \"Europe/London\"\n\n    @patch(\"par_cc_usage.utils.datetime\")\n    def test_detect_system_timezone_with_tzname_mapping(self, mock_datetime):\n        \"\"\"Test timezone detection using tzname mapping.\"\"\"\n        # Mock timezone object with tzname method\n        mock_tz = type('MockTZ', (), {})()\n        mock_tz.tzname = lambda dt: \"PST\"\n\n        mock_dt = type('MockDT', (), {})()\n        mock_dt.tzinfo = mock_tz\n\n        mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n        result = detect_system_timezone()\n        assert result == \"America/Los_Angeles\"\n\n    @patch(\"par_cc_usage.utils.datetime\")\n    def test_detect_system_timezone_with_utc_offset(self, mock_datetime):\n        \"\"\"Test timezone detection using UTC offset.\"\"\"\n        from datetime import timedelta\n\n        # Mock timezone object without zone/key/tzname attributes\n        mock_tz = type('MockTZ', (), {})()\n\n        mock_dt = type('MockDT', (), {})()\n        mock_dt.tzinfo = mock_tz\n        mock_dt.utcoffset = lambda: timedelta(hours=-8)  # Add utcoffset method\n\n        # Mock utcoffset to return -8 hours (PST)\n        mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n        result = detect_system_timezone()\n        assert result == \"America/Los_Angeles\"\n\n    @patch(\"par_cc_usage.utils.datetime\")\n    def test_detect_system_timezone_with_unknown_tzname(self, mock_datetime):\n        \"\"\"Test timezone detection with unknown tzname.\"\"\"\n        # Mock timezone object with unknown tzname\n        mock_tz = type('MockTZ', (), {})()\n        mock_tz.tzname = lambda dt: \"UNKNOWN\"\n\n        mock_dt = type('MockDT', (), {})()\n        mock_dt.tzinfo = mock_tz\n\n        mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n        result = detect_system_timezone()\n        assert result == \"America/Los_Angeles\"  # Should fall back to default\n\n    @patch(\"par_cc_usage.utils.datetime\")\n    def test_detect_system_timezone_exception_fallback(self, mock_datetime):\n        \"\"\"Test timezone detection fallback when exception occurs.\"\"\"\n        # Mock datetime to raise an exception\n        mock_datetime.now.side_effect = Exception(\"Mock error\")\n\n        result = detect_system_timezone()\n        assert result == \"America/Los_Angeles\"\n\n    @patch(\"par_cc_usage.utils.datetime\")\n    def test_detect_system_timezone_none_tzinfo(self, mock_datetime):\n        \"\"\"Test timezone detection when tzinfo is None.\"\"\"\n        mock_dt = type('MockDT', (), {})()\n        mock_dt.tzinfo = None\n\n        mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n        result = detect_system_timezone()\n        assert result == \"America/Los_Angeles\"\n\n    def test_detect_system_timezone_common_timezones(self):\n        \"\"\"Test that common timezone abbreviations map correctly.\"\"\"\n        timezone_mappings = {\n            \"EST\": \"America/New_York\",\n            \"EDT\": \"America/New_York\",\n            \"CST\": \"America/Chicago\",\n            \"CDT\": \"America/Chicago\",\n            \"MST\": \"America/Denver\",\n            \"MDT\": \"America/Denver\",\n            \"PST\": \"America/Los_Angeles\",\n            \"PDT\": \"America/Los_Angeles\",\n            \"UTC\": \"UTC\",\n            \"GMT\": \"UTC\",\n        }\n\n        for abbrev, expected in timezone_mappings.items():\n            with patch(\"par_cc_usage.utils.datetime\") as mock_datetime:\n                # Mock timezone object with tzname method\n                mock_tz = type('MockTZ', (), {})()\n                mock_tz.tzname = lambda dt, _abbrev=abbrev: _abbrev\n\n                mock_dt = type('MockDT', (), {})()\n                mock_dt.tzinfo = mock_tz\n\n                mock_datetime.now.return_value.astimezone.return_value = mock_dt\n\n                result = detect_system_timezone()\n                assert result == expected, f\"Expected {expected} for {abbrev}, got {result}\"\n"}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01Da3wGUVDsQvqjd2hDthSEM","sessionUpdate":"tool_call_update","status":"completed"}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":""}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"Now"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" let"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" me check"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the debug"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"_"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"cost"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"."}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"py file -"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" issue is that imports"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" are not"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" at"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the top because"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" of"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the sys"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":".path manipulation"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"."}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" This"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" is actually"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" intent"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"ional in"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" debug"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" scripts"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":","}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" but we can"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" ad"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"d a"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" no"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"qa comment to suppress the warning"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":":"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_019Du38kPmEaGH1fsgNx57rr","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Edit","kind":"edit","content":[],"locations":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_019Du38kPmEaGH1fsgNx57rr","sessionUpdate":"tool_call","rawInput":{"file_path":"/Users/probello/Repos/par_cc_usage/debug_cost.py","old_string":"from par_cc_usage.config import load_config\nfrom par_cc_usage.pricing import calculate_token_cost, debug_model_pricing\nfrom par_cc_usage.token_calculator import build_usage_snapshot","new_string":"from par_cc_usage.config import load_config  # noqa: E402\nfrom par_cc_usage.pricing import calculate_token_cost, debug_model_pricing  # noqa: E402\nfrom par_cc_usage.token_calculator import build_usage_snapshot  # noqa: E402"},"status":"pending","title":"Edit `/Users/probello/Repos/par_cc_usage/debug_cost.py`","kind":"edit","content":[{"type":"diff","path":"/Users/probello/Repos/par_cc_usage/debug_cost.py","oldText":"from par_cc_usage.config import load_config\nfrom par_cc_usage.pricing import calculate_token_cost, debug_model_pricing\nfrom par_cc_usage.token_calculator import build_usage_snapshot","newText":"from par_cc_usage.config import load_config  # noqa: E402\nfrom par_cc_usage.pricing import calculate_token_cost, debug_model_pricing  # noqa: E402\nfrom par_cc_usage.token_calculator import build_usage_snapshot  # noqa: E402"}],"locations":[{"path":"/Users/probello/Repos/par_cc_usage/debug_cost.py"}]}}}
{"jsonrpc":"2.0","id":22,"method":"fs/read_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/debug_cost.py"}}
{"jsonrpc":"2.0","id":23,"method":"fs/write_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/debug_cost.py","content":"#!/usr/bin/env python3\n\"\"\"Debug script to analyze cost calculations.\"\"\"\n\nimport asyncio\nimport sys\nfrom pathlib import Path\n\n# Add the src directory to the path\nsrc_path = Path(__file__).parent / \"src\"\nsys.path.insert(0, str(src_path))\n\nfrom par_cc_usage.config import load_config  # noqa: E402\nfrom par_cc_usage.pricing import calculate_token_cost, debug_model_pricing  # noqa: E402\nfrom par_cc_usage.token_calculator import build_usage_snapshot  # noqa: E402\n\n\nasync def main():\n    \"\"\"Debug cost calculations.\"\"\"\n    config = load_config()\n\n    print(\"=== Building usage snapshot ===\")\n    snapshot = await build_usage_snapshot(config, progress_callback=None, suppress_output=True)\n\n    # Get current unified block\n    from par_cc_usage.token_calculator import get_current_unified_block\n    current_block = get_current_unified_block(snapshot.unified_blocks)\n\n    if not current_block:\n        print(\"No current unified block found\")\n        return\n\n    print(f\"=== Current Unified Block ({current_block.id}) ===\")\n    print(f\"Total entries: {len(current_block.entries)}\")\n    print(f\"Total tokens (display): {current_block.total_tokens:,}\")\n    print(f\"Total tokens (actual): {current_block.actual_tokens:,}\")\n    print(f\"Messages processed: {current_block.messages_processed}\")\n    print(f\"Models used: {current_block.full_model_names}\")\n\n    # Check a few sample entries\n    print(\"\\n=== Sample entries (first 5) ===\")\n    total_manual_cost = 0.0\n\n    for i, entry in enumerate(current_block.entries[:5]):\n        usage = entry.token_usage\n        print(f\"\\nEntry {i+1}:\")\n        print(f\"  Model: {entry.full_model_name}\")\n        print(f\"  Display tokens: in={usage.input_tokens:,}, out={usage.output_tokens:,}, cache_create={usage.cache_creation_input_tokens:,}, cache_read={usage.cache_read_input_tokens:,}\")\n        print(f\"  Actual tokens: in={usage.actual_input_tokens:,}, out={usage.actual_output_tokens:,}, cache_create={usage.actual_cache_creation_input_tokens:,}, cache_read={usage.actual_cache_read_input_tokens:,}\")\n\n        # Calculate cost for this entry\n        cost = await calculate_token_cost(\n            entry.full_model_name,\n            usage.actual_input_tokens,\n            usage.actual_output_tokens,\n            usage.actual_cache_creation_input_tokens,\n            usage.actual_cache_read_input_tokens,\n        )\n        print(f\"  Cost: ${cost.total_cost:.4f}\")\n        total_manual_cost += cost.total_cost\n\n    print(f\"\\n=== Manual cost calculation (first 5 entries): ${total_manual_cost:.4f} ===\")\n\n    # Get unified block total cost\n    unified_cost = await snapshot.get_unified_block_total_cost()\n    print(f\"=== Unified block total cost: ${unified_cost:.4f} ===\")\n\n    # Debug pricing for the most common model\n    if current_block.full_model_names:\n        most_common_model = next(iter(current_block.full_model_names))\n        print(f\"\\n=== Pricing debug for {most_common_model} ===\")\n        pricing_debug = await debug_model_pricing(most_common_model)\n        for key, value in pricing_debug.items():\n            print(f\"  {key}: {value}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_019Du38kPmEaGH1fsgNx57rr","sessionUpdate":"tool_call_update","status":"completed"}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":""}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"Now"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" let"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" me check"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the test_"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"display"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"."}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"py import"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" issue:"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01UB3DrrvDwVfdMwNaBSa3ce","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Read File","kind":"read","locations":[{"line":0}],"content":[]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01UB3DrrvDwVfdMwNaBSa3ce","sessionUpdate":"tool_call","rawInput":{"file_path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","offset":1,"limit":40},"status":"pending","title":"Read /Users/probello/Repos/par_cc_usage/tests/test_display.py (2 - 41)","kind":"read","locations":[{"path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","line":1}],"content":[]}}}
{"jsonrpc":"2.0","id":24,"method":"fs/read_text_file","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","path":"/Users/probello/Repos/par_cc_usage/tests/test_display.py","line":1,"limit":40}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01UB3DrrvDwVfdMwNaBSa3ce","sessionUpdate":"tool_call_update","status":"completed","content":[{"type":"content","content":{"type":"text","text":"```\n\"\"\"\nTests for the display module.\n\"\"\"\n\nfrom datetime import UTC, datetime, timedelta, timezone\nfrom unittest.mock import Mock, patch\n\nimport pytest\nfrom rich.console import Console\nfrom rich.panel import Panel\nfrom rich.table import Table\nfrom rich.text import Text\n\nfrom par_cc_usage.display import MonitorDisplay\nfrom par_cc_usage.enums import DisplayMode\n\n\ndef create_mock_config(display_mode=DisplayMode.COMPACT):\n    \"\"\"Create a mock config with all required fields for P90 functionality.\"\"\"\n    config = Mock()\n    from par_cc_usage.config import DisplayConfig\n    config.display = DisplayConfig(display_mode=display_mode)\n    config.max_cost_encountered = 0.0\n    config.max_tokens_encountered = 0\n    config.max_messages_encountered = 0\n    config.max_unified_block_tokens_encountered = 0\n    config.max_unified_block_messages_encountered = 0\n    config.max_unified_block_cost_encountered = 0.0\n    # Add P90 fields\n    config.p90_unified_block_tokens_encountered = 0\n    config.p90_unified_block_messages_encountered = 0\n    config.p90_unified_block_cost_encountered = 0.0\n    return config\nfrom par_cc_usage.models import Project, Session, TokenBlock, TokenUsage, UsageSnapshot\n\n\nclass TestMonitorDisplay:\n    \"\"\"Test the MonitorDisplay class.\"\"\"\n\n    def test_initialization_default(self):\n```"}}]}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":""}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":"I"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" see"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the issue"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" -"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the import"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" is"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" after"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":" the function definition. Let me fix that"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"sessionUpdate":"agent_message_chunk","content":{"type":"text","text":":"}}}}
{"jsonrpc":"2.0","method":"session/update","params":{"sessionId":"019a1724-2098-7706-80dd-9aa68d6bf65e","update":{"toolCallId":"toolu_01RVcEHtTygevjzcuQ54S1GP","sessionUpdate":"tool_call","rawInput":{},"status":"pending","title":"Edit","kind":"edit","content":[],"locations":[]}}}
